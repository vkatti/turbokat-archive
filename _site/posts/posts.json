[
  {
    "path": "posts/2021-07-17-programmingwithdplyr/",
    "title": "Programming with R {dplyr} - As I Understand It!!",
    "description": "This post is about how {dplyr} functions can be used to create your own functions..",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2021-07-17",
    "categories": [
      "R",
      "dplyr",
      "NSE"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nInspiration\r\nData\r\n\r\nselect()\r\nPassing raw column names\r\nPassing multiple raw column names using … argument\r\nPassing a character vector of column names\r\n\r\nfilter()\r\nPassing single raw criteria\r\nPassing multiple raw criteria using … argument\r\nPassing single criteria as a character string\r\nPassing multiple criteria as character vector\r\n\r\nmutate()\r\nPassing the column name as raw name\r\nPassing the new variable name as character string (direct)\r\nPassing the new variable name as character string (indirect)\r\n\r\narrange()\r\nPassing single raw name\r\nPassing multiple raw names using ... argument\r\nPass single column name as string\r\nPass multiple column name as string\r\n\r\ngroup_by()\r\nPassing single raw name\r\nPassing multiple raw names using the ... operator\r\nPassing single or multiple column names as character string\r\n\r\n(Slightly Better) Examples\r\nmutate() example\r\ngroup_by() example\r\nMore ideas\r\n\r\nConclusion\r\nReferences\r\n\r\n\r\nd-article div.sourceCode code,\r\nd-article pre code {\r\n    font-family: \"Fira Code\", monospace;\r\n}\r\nIntroduction\r\nThe purpose of this document is to act as a quick guide for myself and others to understand how to use dplyr effectively to create dynamic functions. The general assumption is that the reader is familiar with the {dplyr} package and how to use it for data wrangling.\r\nIn this document, we will explore how to create functions using the popular dplyr verbs like select, filter, mutate, arrange and finally group_by with summarise.\r\nInspiration\r\nI regularly deal with event-related information with event date and few other columns like event type, root cause etc. Most reports usually involve calculating number of events that took place on a monthly, quarterly or annual basis, sometimes split by event type, root cause and other columns. After a few reports I realized that I am basically writing the same code over and over again to calculate these KPIs. Keeping the DRY (Don't Repeat Yourself) principle in mind, I managed to write a few functions to calculate these KPIs with a few dynamic variables. Following is an attempt to articulate what I learnt while creating those functions.\r\nData\r\nWe shall use the Texas Housing Sales data, available as a tibble in the popular ggplot2 package as reference data. It contains monthly information about the housing market in Texas provided by the TAMU real estate center, https://www.recenter.tamu.edu/. It has 8602 observations and 9 variables.\r\n\r\n\r\ntxhousing <- ggplot2::txhousing\r\ndplyr::glimpse(txhousing)\r\n\r\n\r\nRows: 8,602\r\nColumns: 9\r\n$ city      <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abile~\r\n$ year      <int> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 20~\r\n$ month     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4,~\r\n$ sales     <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100~\r\n$ volume    <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 1391~\r\n$ median    <dbl> 71400, 58700, 58100, 68600, 67300, 66900, 73500, 7~\r\n$ listings  <dbl> 701, 746, 784, 785, 794, 780, 742, 765, 771, 764, ~\r\n$ inventory <dbl> 6.3, 6.6, 6.8, 6.9, 6.8, 6.6, 6.2, 6.4, 6.5, 6.6, ~\r\n$ date      <dbl> 2000.000, 2000.083, 2000.167, 2000.250, 2000.333, ~\r\n\r\nWe shall refer the above data in all the following sections.\r\nselect()\r\nWhen using dplyr functions, the two most popular ways to pass column names is either as bare names i.e. column names without enclosing them in quotes like sales or volume OR pass them as a character string like “sales” or ‘volume’. You could also pass a character vector like c(\"sales\", \"volume\"). In this section we will explore the 3 ways to dynamically select the columns we want.\r\nPassing raw column names\r\nIn this method, we pass the raw name of the column we want to select and use the embrace of curly-curly brackets to pass the raw name. For multiple columns, we can pass the raw names as a single vector.\r\n\r\n\r\nselect_raw <- function(df, var) {\r\n  dplyr::select(.data = df, {{var}}) %>%     # embrace of curly-curly {{}} brackets\r\n    head()                                   # to limit the number of output rows in this example.\r\n}\r\nselect_raw(txhousing, sales)                 # pass single raw name\r\n\r\n\r\n# A tibble: 6 x 1\r\n  sales\r\n  <dbl>\r\n1    72\r\n2    98\r\n3   130\r\n4    98\r\n5   141\r\n6   156\r\n\r\nselect_raw(txhousing, c(sales, volume))      # pass a vector of raw names for multiple columns\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nIf passing multiple raw names as vector as in the select_raw() feels like an unnecessary complication, try the next method.\r\nPassing multiple raw column names using … argument\r\nIn this method, we use the … argument to pass the raw names of the columns we want to select.\r\n\r\n\r\nmy_select <- function(df, ...) {\r\n  dplyr::select(.data = df, ...) %>% \r\n    head()\r\n}\r\n\r\nmy_select(txhousing, sales, volume)          # pass multiple raw names directly\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nPassing a character vector of column names\r\nIf we have the column names as a character vector, we use the all_of function to pass the character vector to the internal select function.\r\n\r\n\r\nmy_select_char <- function(df, cols) {\r\n  dplyr::select(.data = df, dplyr::all_of(cols)) %>% \r\n    head()\r\n}\r\n\r\nmy_cols <- c(\"sales\",\"volume\")\r\nmy_select_char(txhousing, my_cols)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nfilter()\r\nIn the previous section, we passed column names either as bare names or character strings. filter() takes one or more expressions/conditions that result in a logical vector, with same length as number of rows in the data.frame/tibble and returns only those rows for which the expression/condition returns TRUE. Following are 2 ways to pass these logical expressions/conditions. I’m using expression and condition interchangeably here. In this context, a condition is an expression that results in a boolean TRUE/FALSE result.\r\nPassing single raw criteria\r\nIn this method, we pass the condition sales > 8000 as a raw/bare expression.\r\n\r\n\r\nfilter_raw <- function(df, cond) {\r\n  dplyr::filter(.data = df, {{cond}})        # embrace of curly-curly {{}} brackets\r\n}\r\n\r\nfilter_raw(txhousing, sales > 8000)          # Pass a single raw criterion\r\n\r\n\r\n# A tibble: 10 x 9\r\n   city     year month sales    volume median listings inventory  date\r\n   <chr>   <int> <int> <dbl>     <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.\r\n 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.\r\n 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.\r\n 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.\r\n 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.\r\n 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.\r\n 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.\r\n 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.\r\n 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.\r\n10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.\r\n\r\nDo you think we can pass multiple bare conditions as a vector, like we did for select_raw() in the previous section? Let us try passing multiple raw criteria as a vector.\r\n\r\n\r\nfilter_raw(txhousing, c(sales > 8000, year > 2010))\r\n\r\n\r\nError: Problem with `filter()` input `..1`.\r\ni Input `..1` is `c(sales > 8000, year > 2010)`.\r\nx Input `..1` must be of size 8602 or 1, not size 17204.\r\n\r\n\r\nPassing multiple raw criteria as a vector doesn’t work like it works for select_raw() function. Let us understand why. Consider the following code:\r\n\r\n\r\nA <- c(TRUE, TRUE)                           # boolean vector of length = 2\r\nB <- c(FALSE, FALSE)                         # boolean vector of length = 2\r\nX <- c(A, B)\r\nX\r\n\r\n\r\n[1]  TRUE  TRUE FALSE FALSE\r\n\r\nNotice that length of X is 4. Similarly, sales > 8000 evaluates to a TRUE/FALSE boolean vector of length 8602 (equal to number of rows in txhousing) and so does year > 2010. So the vector c(sales > 8000, year > 2010) becomes a TRUE/FALSE boolean vector of length 17204, which results in an error.\r\nPassing multiple raw criteria using … argument\r\nTo pass multiple raw criteria, we can use the ... argument.\r\n\r\n\r\nmy_filter <- function(df, ...) { \r\n  dplyr::filter(.data = df, ...)                # pass the dots argument\r\n  }\r\n\r\nmy_filter(txhousing, sales > 8000, year > 2010) # pass multiple raw criteria\r\n\r\n\r\n# A tibble: 8 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\r\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\r\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\r\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n\r\nPassing single criteria as a character string\r\nBy default, dplyr::filter() does not accept conditions as character strings. Following is an example which results in error\r\n\r\n\r\ndplyr::filter(txhousing, \"sales > 8000\")\r\n\r\n\r\nError: Problem with `filter()` input `..1`.\r\ni Input `..1` is `\"sales > 8000\"`.\r\nx Input `..1` must be a logical vector, not a character.\r\n\r\n\r\nWe need to convert the character condition into a raw expression.\r\n\r\n\r\nmy_filter_string <- function(df, cond) {\r\n  dplyr::filter(.data = df, eval(parse(text = cond)))   # convert text to raw criterion\r\n}\r\n\r\nmy_filter_string(txhousing, \"sales > 8000\")             # pass single text string as criteria\r\n\r\n\r\n# A tibble: 10 x 9\r\n   city     year month sales    volume median listings inventory  date\r\n   <chr>   <int> <int> <dbl>     <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.\r\n 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.\r\n 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.\r\n 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.\r\n 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.\r\n 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.\r\n 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.\r\n 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.\r\n 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.\r\n10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.\r\n\r\nThe special sauce here is the eval(parse(text = ...)) combo that converts the long text criteria into a single raw criteria and passes it to the internal filter() function.\r\nPassing multiple criteria as character vector\r\nWhat if want to pass multiple criteria as a string vector? In such a situation, we must combine all the string conditions into a single long string condition using paste0(..., collapse = \" & \"). The paste0(\"(\", cond, \")\", collapse = \" & \") combines all the criteria into a single long criteria, but still a text string.\r\n\r\n\r\nmy_filter_strings <- function(df, cond) { \r\n  filter_text <- paste0(\"(\", cond, \")\", collapse = \" & \")   # combine all criteria\r\n  message(\"Filter Condition: \", filter_text)                # (OPTIONAL) show the combined filter string\r\n  dplyr::filter(.data = df, eval(parse(text = filter_text)))# convert text to raw criterion\r\n  }\r\n\r\nmy_filter_criteria <- c(\"sales > 8000\", \"year > 2010\")\r\nmy_filter_strings(txhousing, my_filter_criteria)\r\n\r\n\r\n# A tibble: 8 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\r\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\r\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\r\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n\r\n\r\n\r\nmy_filter_criteria_with_OR <- c(\"sales > 8000 | sales < 50\", \"year > 2010\")\r\n\r\n# NOTE: OR criteria must be a single string separated by pipe '|' as in example below.\r\nmy_filter_strings(txhousing, my_filter_criteria_with_OR)\r\n\r\n\r\n# A tibble: 315 x 9\r\n   city        year month sales volume median listings inventory  date\r\n   <chr>      <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Brownsvil~  2011     1    48 4.97e6  83300      784      12.6 2011 \r\n 2 Brownsvil~  2011     2    47 5.56e6 101400      776      12.7 2011.\r\n 3 Brownsvil~  2011     7    47 4.81e6  91200      749      13.1 2012.\r\n 4 Brownsvil~  2011    12    39 4.20e6  86800      726      12.4 2012.\r\n 5 Brownsvil~  2012     1    43 3.89e6  85000      791      13.6 2012 \r\n 6 Brownsvil~  2012     3    27 2.98e6  93800      734      13.3 2012.\r\n 7 Brownsvil~  2012    11    41 5.12e6  99000      807      14   2013.\r\n 8 Brownsvil~  2013    11    38 4.82e6 108000      859      13.4 2014.\r\n 9 Brownsvil~  2015     1    41 5.40e6  97000      733      10.7 2015 \r\n10 Galveston   2011     1    43 8.88e6 170000     1015      13.7 2011 \r\n# ... with 305 more rows\r\n\r\nmutate()\r\nmutate() allows you to add new columns or modify existing columns. In the example below, we will create a new column volume_in_millions from the existing column volume. The names of both the columns can be passed to the function either as raw names or character strings.\r\nPassing the column name as raw name\r\n\r\n\r\nmutate_raw <- function(df, new_col_raw, old_col_raw, num = 1) { \r\n  dplyr::mutate(.data = df, {{new_col_raw}} := {{old_col_raw}}/num) %>% \r\n    head()\r\n}\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>% \r\n  mutate_raw(vol_in_millions, volume, 1E6) # pass raw column names w/o quotes\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\nPassing the new variable name as character string (direct)\r\n\r\n\r\nmutate_text <- function(df, new_col_str, old_col_str, num = 1) { \r\n  dplyr::mutate(.data = df, {{new_col_str}} := df[[old_col_str]]/num) %>% \r\n    head()\r\n}\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>%\r\n  mutate_text(\"vol_in_millions\", \"volume\", 1E6) # pass column names as strings\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\nPassing the new variable name as character string (indirect)\r\nInstead of passing the name of the variable as a character string as an argument, we can pass a variable containing the name of the variable. In the below example, the name of the new variable is stored in new_var. Using the new {glue} syntax, enabled by the walrus operator :=, we substitute the new_var variable with its value.\r\n\r\n\r\nmutate_var <- function(df, new_col_var, old_col_var, num = 1) {\r\n  dplyr::mutate(.data = df, \"{new_col_var}\" := df[[old_col_var]]/num) %>% \r\n    head()\r\n}\r\n\r\nnew_var <- \"vol_in_millions\"\r\nold_var <- \"volume\"\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>%\r\n  mutate_var(new_var, old_var, 1E6)  # pass column names as variables\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\narrange()\r\narrange() sorts the rows of a data frame by the values of selected columns. By default, it sorts in Ascending order. To force a column to sort in Descending order, we must use the desc() function.\r\nPassing single raw name\r\n\r\n\r\narrange_raw <- function(df, var) {\r\n  dplyr::arrange(.data = df, {{var}}) %>%    # embrace of curly-curly {{}} brackets\r\n    head()\r\n}\r\n\r\narrange_raw(txhousing, sales)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.\r\n2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.\r\n3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 \r\n4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 \r\n5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.\r\n6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.\r\n\r\narrange_raw(txhousing, desc(sales))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\r\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n\r\narrange_raw() fails when we pass multiple raw names as a vector.\r\n\r\n\r\narrange_raw(txhousing, c(sales, volume))\r\n\r\n\r\nError: arrange() failed at implicit mutate() step. \r\n* Problem with `mutate()` column `..1`.\r\ni `..1 = c(sales, volume)`.\r\ni `..1` must be size 8602 or 1, not 17204.\r\n\r\n\r\nPassing multiple raw names using ... argument\r\nTo pass multiple raw names, we must use the ... argument.\r\n\r\n\r\narrange_raw_multiple <- function(df, ...) {\r\n  dplyr::arrange(.data = df, ...) %>% \r\n    head()\r\n}\r\n\r\narrange_raw_multiple(txhousing, city, sales)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales  volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Abilene  2003     1    68 5385000  70000      668       5.4  2003\r\n2 Abilene  2011     1    68 8834493 123300      809       6.1  2011\r\n3 Abilene  2009     1    70 8414801  92900      861       6.3  2009\r\n4 Abilene  2000     1    72 5380000  71400      701       6.3  2000\r\n5 Abilene  2010     1    73 9130783 112200      868       6.4  2010\r\n6 Abilene  2001     1    75 5730000  64500      779       6.8  2001\r\n\r\narrange_raw_multiple(txhousing, city, desc(sales))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales   volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>    <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Abilene  2015     7   268 45845730 148700      986       5   2016.\r\n2 Abilene  2015     6   260 41396230 141500      965       5   2015.\r\n3 Abilene  2007     7   239 29315000 114300      940       5.2 2008.\r\n4 Abilene  2013     8   236 30777727 120000      976       5.4 2014.\r\n5 Abilene  2014     7   231 35861350 145800     1033       5.8 2014.\r\n6 Abilene  2005     6   230 24050000  92500      664       4.1 2005.\r\n\r\nPass single column name as string\r\n\r\n\r\narrange_str <- function(df, var, .desc = FALSE) {\r\n  if (.desc) {\r\n    dplyr::arrange(.data = df, desc(df[[var]])) %>% head()\r\n  } else {\r\n    dplyr::arrange(.data = df, df[[var]]) %>% head()\r\n  }\r\n}\r\n\r\narrange_str(txhousing, \"sales\")\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.\r\n2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.\r\n3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 \r\n4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 \r\n5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.\r\n6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.\r\n\r\narrange_str(txhousing, \"sales\", .desc = TRUE)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\r\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n\r\nPass multiple column name as string\r\n\r\n\r\narrange_str_multiple <- function(df, var, desc = FALSE) {\r\n  if (desc) {\r\n    dplyr::arrange(.data = df, desc(df[var])) %>% head()\r\n  } else {\r\n    dplyr::arrange(.data = df, df[var]) %>% head()\r\n  }\r\n}\r\n\r\n# This function arranges the dataframe either all ascending\r\n# or all descending. Definitely need a better example.\r\n\r\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Paris        2000     1    19 1.44e6  71700      286       7.5  2000\r\n2 San Marcos   2000     1    22 2.38e6 106700      190       6.3  2000\r\n3 Lufkin       2000     1    28 2.28e6  68000       NA      NA    2000\r\n4 Harlingen    2000     1    31 3.91e6  87500      644      24.9  2000\r\n5 Galveston    2000     1    37 4.56e6  95000      636       9.1  2000\r\n6 Port Arthur  2000     1    40 3.09e6  68300      314       5.6  2000\r\n\r\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"), desc = TRUE)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city       year month sales   volume median listings inventory  date\r\n  <chr>     <int> <int> <dbl>    <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston    2015     7  8945   2.57e9 217600    23875       3.4 2016.\r\n2 Dallas     2015     7  7038   2.02e9 233000    12292       2.4 2016.\r\n3 Austin     2015     7  3466   1.15e9 264600     7913       3   2016.\r\n4 San Anto~  2015     7  2962   7.05e8 198100     9462       4.1 2016.\r\n5 Collin C~  2015     7  1861   6.14e8 292600     2809       2.1 2016.\r\n6 Fort Bend  2015     7  1372   4.32e8 280400     3328       3.1 2016.\r\n\r\ngroup_by()\r\nIn group_by(), we select which columns to, well, group by! (Damn these well-named functions!). So one can use the same techniques as select() to choose the columns.\r\nIn the following examples, we will create only one summarised value total_sales for simplicity.\r\nPassing single raw name\r\n\r\n\r\ngroup_raw <- function(df, grp) {\r\n  df %>% \r\n    group_by({{grp}}) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_raw(txhousing, year)        # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw(txhousing, month)       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 2\r\n  month total_sales\r\n  <int>       <dbl>\r\n1     1      245924\r\n2     2      296410\r\n3     3      386909\r\n4     4      397332\r\n5     5      448968\r\n\r\nPassing multiple raw names using the ... operator\r\n\r\n\r\ngroup_raw_multiple <- function(df, ...) {\r\n  df %>% \r\n    group_by(...) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n = 5)\r\n}\r\n\r\ngroup_raw_multiple(txhousing, year)              # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw_multiple(txhousing, year, month)       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\nPassing single or multiple column names as character string\r\n\r\n\r\ngroup_str <- function(df, grp) {\r\n  df %>% \r\n    group_by(df[grp]) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_str(txhousing, \"year\")                   # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_str(txhousing, c(\"year\", \"month\"))       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\n# The same column names can be passed as variables containing the character names\r\nyr <- \"year\"\r\ngroup_str(txhousing, yr)\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\nyrmon <- c(\"year\", \"month\")\r\ngroup_str(txhousing, yrmon)\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\nIf you want the summarise column to have a custom name like total_<sumvar>, then you can wrap the value in quotes as below. This method uses the glue syntax enabled by the := walrus operator. The walrus operator takes either a raw name or a character string on its LHS.\r\n\r\n\r\ngroup_raw2 <- function(df, grp, sumvar) {\r\n  df %>% \r\n    group_by({{grp}}) %>% \r\n    summarise(\"total_{{sumvar}}\" := sum({{sumvar}}, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_raw2(txhousing, year, sales)            # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw2(txhousing, month, listings)        # Sum of listings per month\r\n\r\n\r\n# A tibble: 5 x 2\r\n  month total_listings\r\n  <int>          <dbl>\r\n1     1        1854661\r\n2     2        1888104\r\n3     3        1949187\r\n4     4        1991278\r\n5     5        2038932\r\n\r\nAfter writing so many examples, I see a pattern. group_by() works with techniques similar to select() while summarise() works with techniques similar to mutate().\r\n(Slightly Better) Examples\r\nThe txhousing is a city-wise monthly sales and volume dataset. It has a year and month column. Let us create a date column and keep only those columns relevant for our custom tx_summary() function.\r\n\r\n\r\nsmall_df <- txhousing %>% \r\n  mutate(date = lubridate::as_date(glue::glue(\"{year}-{month}-01\"))) %>% \r\n  select(city, date, sales, volume)\r\n\r\n\r\n\r\nmutate() example\r\nNow let us create the create_ymq() function. This function would take 2 arguments, a data frame df and a raw name of a date column.\r\n\r\n\r\ncreate_ymq <- function(df, date_col) {\r\n  stopifnot(inherits(df, \"data.frame\"))\r\n  stopifnot(class(df %>% dplyr::pull({{date_col}})) == 'Date')\r\n  dplyr::mutate(df,\r\n                Year = lubridate::year({{date_col}}),\r\n                nHalf = lubridate::semester({{date_col}}),\r\n                yHalf = lubridate::semester({{date_col}}, with_year = TRUE),\r\n                dHalf = paste0(lubridate::semester({{date_col}}), \"H\", format({{date_col}},\"%y\")),\r\n                nQtr = lubridate::quarter({{date_col}}),\r\n                yQtr = lubridate::quarter({{date_col}}, with_year = TRUE),\r\n                dQtr = paste0(lubridate::quarter({{date_col}}),\"Q\", format({{date_col}},\"%y\")),\r\n                Month = lubridate::month({{date_col}}),\r\n                yMonth = as.numeric(format({{date_col}}, \"%Y.%m\")),\r\n                dMonth = format({{date_col}}, \"%b %Y\")\r\n                )\r\n}\r\n\r\ncreate_ymq(df = small_df, date_col = date) %>% glimpse()\r\n\r\n\r\nRows: 8,602\r\nColumns: 14\r\n$ city   <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\"~\r\n$ date   <date> 2000-01-01, 2000-02-01, 2000-03-01, 2000-04-01, 2000~\r\n$ sales  <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100, 9~\r\n$ volume <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 1391000~\r\n$ Year   <dbl> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,~\r\n$ nHalf  <int> 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,~\r\n$ yHalf  <dbl> 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.~\r\n$ dHalf  <chr> \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"2H00~\r\n$ nQtr   <int> 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2,~\r\n$ yQtr   <dbl> 2000.1, 2000.1, 2000.1, 2000.2, 2000.2, 2000.2, 2000.~\r\n$ dQtr   <chr> \"1Q00\", \"1Q00\", \"1Q00\", \"2Q00\", \"2Q00\", \"2Q00\", \"3Q00~\r\n$ Month  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5,~\r\n$ yMonth <dbl> 2000.01, 2000.02, 2000.03, 2000.04, 2000.05, 2000.06,~\r\n$ dMonth <chr> \"Jan 2000\", \"Feb 2000\", \"Mar 2000\", \"Apr 2000\", \"May ~\r\n\r\ngroup_by() example\r\nNow that we have a function that creates various date-related columns, let us create a function that let’s you create summary tables like annual sales per city, quarterly volumes per city etc.\r\n\r\n\r\ntx_summary <- function(df, grp_col, sum_col) {\r\n  df %>% \r\n    group_by(city, {{grp_col}}) %>% \r\n    summarise(\"total_{{sum_col}}\" := sum({{sum_col}}, na.rm = TRUE), .groups = 'drop')\r\n}\r\n\r\n\r\n\r\nUsing these 2 functions, we can now create multiple summary tables\r\n\r\n\r\nsmall_df_with_date_cols <- small_df %>% create_ymq(date_col = date)\r\n\r\n# Annual Sales per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = Year, sum_col = sales)\r\n\r\n\r\n# A tibble: 736 x 3\r\n   city     Year total_sales\r\n   <chr>   <dbl>       <dbl>\r\n 1 Abilene  2000        1375\r\n 2 Abilene  2001        1431\r\n 3 Abilene  2002        1516\r\n 4 Abilene  2003        1632\r\n 5 Abilene  2004        1830\r\n 6 Abilene  2005        1977\r\n 7 Abilene  2006        1997\r\n 8 Abilene  2007        2003\r\n 9 Abilene  2008        1651\r\n10 Abilene  2009        1634\r\n# ... with 726 more rows\r\n\r\n# Half Yearly volumes per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yHalf, sum_col = volume)\r\n\r\n\r\n# A tibble: 1,472 x 3\r\n   city    yHalf total_volume\r\n   <chr>   <dbl>        <dbl>\r\n 1 Abilene 2000.     55400000\r\n 2 Abilene 2000.     53175000\r\n 3 Abilene 2001.     55795000\r\n 4 Abilene 2001.     58570000\r\n 5 Abilene 2002.     55305000\r\n 6 Abilene 2002.     63370000\r\n 7 Abilene 2003.     58175000\r\n 8 Abilene 2003.     77500000\r\n 9 Abilene 2004.     74205000\r\n10 Abilene 2004.     85465000\r\n# ... with 1,462 more rows\r\n\r\n# Quarterly Sales per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yQtr, sum_col = sales)\r\n\r\n\r\n# A tibble: 2,898 x 3\r\n   city     yQtr total_sales\r\n   <chr>   <dbl>       <dbl>\r\n 1 Abilene 2000.         300\r\n 2 Abilene 2000.         395\r\n 3 Abilene 2000.         387\r\n 4 Abilene 2000.         293\r\n 5 Abilene 2001.         305\r\n 6 Abilene 2001.         394\r\n 7 Abilene 2001.         401\r\n 8 Abilene 2001.         331\r\n 9 Abilene 2002.         295\r\n10 Abilene 2002.         425\r\n# ... with 2,888 more rows\r\n\r\n# Monthly Volumes per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yMonth, sum_col = volume)\r\n\r\n\r\n# A tibble: 8,602 x 3\r\n   city    yMonth total_volume\r\n   <chr>    <dbl>        <dbl>\r\n 1 Abilene  2000.      5380000\r\n 2 Abilene  2000.      6505000\r\n 3 Abilene  2000.      9285000\r\n 4 Abilene  2000.      9730000\r\n 5 Abilene  2000.     10590000\r\n 6 Abilene  2000.     13910000\r\n 7 Abilene  2000.     12635000\r\n 8 Abilene  2000.     10710000\r\n 9 Abilene  2000.      7615000\r\n10 Abilene  2000.      7040000\r\n# ... with 8,592 more rows\r\n\r\nMore ideas\r\nYou could further extend this by creating a custom filtering function that gives you, say, the rows with the highest or lowest total_sales or total_volume.\r\nConclusion\r\nThe ability to create such dynamic functions, enabled by the wonderful {dplyr} package, allows us to level-up in terms of programming with R and helps make our code neat and tidy.\r\nHow I feel while creating custom functions with {dplyr}! I can almost hear the music!References\r\nHadley Wickham, Romain François, Lionel Henry and Kirill Müller (2021). dplyr: A Grammar of Data Manipulation. R package version 1.0.7. https://CRAN.R-project.org/package=dplyr\r\nhttps://dplyr.tidyverse.org/articles/programming.html\r\nGarrett Grolemund, Hadley Wickham (2011). Dates and Times Made Easy with lubridate. Journal of Statistical Software, 40(3), 1-25. URL https://www.jstatsoft.org/v40/i03/.\r\nH. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016.\r\nJim Hester (2020). glue: Interpreted String Literals. R package version 1.4.2. https://CRAN.R-project.org/package=glue\r\n\r\n\r\n\r\n",
    "preview": "https://i.gifer.com/8inO.gif",
    "last_modified": "2021-07-18T00:57:27+05:30",
    "input_file": {}
  }
]
