[
  {
    "path": "posts/2022-02-18-deepdiveintro/",
    "title": "Deep Dive Series",
    "description": "What, Why and Why Not about a blog series featuring functions from R and Python packages.",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2022-02-18",
    "categories": [
      "Rstats",
      "Python",
      "functions"
    ],
    "contents": "\r\n\r\nThis is the first of many deep-dive blogs I intend to write over the\r\ncourse of few months. I will cover some common (and not-so-common)\r\nfunctions from various R and Python packages. I choose those functions\r\nthat deal with basic user actions like reading/writing files, some\r\ncommon data wrangling and possibly some visualizations.\r\nSome of you may say that there is enough documentation available\r\nonline, why do we need this? I feel that while R, and to some extent\r\nPython, does have enough documentation, we get only code examples. Only\r\nin vignettes do we see the code outputs but when you have functions\r\ndealing with external files/systems, rarely do you get any views or\r\nscreenshots of these external entities. My selective laziness prevents\r\nme from running the code examples in the documentation but pushes me to\r\nwrite blogs about inadequate documentation!\r\n\r\nIf you show code anywhere, you must show its output along\r\nwith it.\r\n\r\nThe second thought is slightly more selfish. I am a victim of scope\r\ncreep in my previous blogs and it took ages to finish each one of them.\r\nThis will prevent that to some extent. I must confess that this will\r\npush me to write consistently and not run out of material soon.\r\nPossible reaction from folks reading this\r\nblog!Wish me luck! I definitely need it.\r\n\r\n\r\n\r\n",
    "preview": "https://c.tenor.com/BDczPTBxVwAAAAAC/deepsea-dive.gif",
    "last_modified": "2022-05-04T20:40:47+05:30",
    "input_file": {}
  },
  {
    "path": "posts/2022-01-18-writingrobustrfunctions/",
    "title": "Writing Robust R Functions",
    "description": "Some designs to validate function arguments.",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2022-01-18",
    "categories": [
      "Rstats",
      "functions"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nWhat do we mean by\r\nRobust Functions?\r\nOur sweet, innocent\r\nand naive Function\r\nScenario 1: Missing\r\nArguments\r\n1.1 Early Exit\r\n1.2 Sensible defaults\r\nwith warnings\r\n\r\nScenario 2: Invalid\r\nArgument Data Type\r\nCharacter arguments\r\nFactor arguments\r\n\r\nScenario 3: Incorrect\r\nArgument Size\r\nA little detour…\r\nScenario\r\n4: Values of Arguments that result in invalid outputs\r\nConclusion\r\nCitations & References\r\n\r\nIntroduction\r\nFunctions in R ( or any other programming language in general) allow\r\nus to encapsulate some lines of code that we want to run again and\r\nagain. Functions are the natural outcome of the DRY\r\n(Don’t Repeat Yourself!) principle. Functions group together a couple of\r\nlines of consistent logic making our code modular and consequently, easy\r\nto manage. However, when we write functions, we need to ensure that they\r\nbehave exactly as we want them to and are able to handle whatever we\r\nthrow at them. By whatever, I mean any and all kinds of inputs. The idea\r\nof creating unbreakable code is idealistic. I say this since creating\r\nrobust functions requires additional code to handle the unwanted inputs\r\nand most useRs write functions during some one-time analysis. Hence we\r\nneed to be pragmatic about how much time and effort we spend trying to\r\nmake our functions robust. Maybe, we need our functions to be just\r\nrobust enough! All I am saying is, if you are creating functions that\r\nwill be used by you and only you i.e. if you have absolute control over\r\nwhat inputs would be provided to your functions, then you can forego\r\ncertain checks and the functions need not be unbreakable. But, if you\r\nintend to write functions that will be used by a larger audience, you\r\nneed to ensure that such functions are able to handle all kinds of\r\ninnocent and malicious intents.\r\nWhat do we mean by Robust\r\nFunctions?\r\nYou must be familiar with the Garbage-In-Garbage-Out\r\nphilosophy of Software engineering. We can think of it in terms of\r\nfunctions, that, given garbage or bad input, you get garbage or bad\r\noutput. For a function to be robust, it must behave in a consistent\r\nmanner for known and correct inputs, however, more importantly, it\r\nmustn’t give us garbage for bad inputs. Rather, it must provide useful\r\noutput (as messages or instructions) which can be further used to inform\r\nthe end-user about possible problems in the inputs to drive proper\r\nusage. The useful output/s in case of bad inputs would ideally be a\r\ncombination of clean early exit and easy-to-understand error messages.\r\nSo we shall try to implement Garbage-In-Useful-Info-Out by\r\nlooking at some ways we can build well-behaved and reliable\r\nfunctions.\r\nInput values passed to a function are more popularly known as\r\narguments or parameters. A robust function must validate the function\r\narguments before proceeding to implement the function logic. If this is\r\nnot done, then the bad arguments will cause some errors in the logic and\r\ndisplay error messages that the end-user may not be familiar with.\r\nWorst-case scenario is when the function doesn’t encounter any errors\r\nand just gives bad results!! Surely, we do not want this unpredictable\r\nbehavior.\r\nEnough Talk, Let’s Fight! - Kungfu Panda\r\n@imgflip.comOur sweet, innocent and\r\nnaive Function\r\nConsider the following function make_date that takes 3\r\nnumeric inputs yyyy, mm and dd\r\nand returns a single ’Date` object.\r\n\r\n\r\nmake_date <-  function(yyyy, mm, dd) {\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\nmy_date <- make_date(yyyy = 2022, mm = 1, dd = 31)\r\nmy_date\r\n\r\n\r\n[1] \"2022-01-31\"\r\n\r\nclass(my_date)\r\n\r\n\r\n[1] \"Date\"\r\n\r\nWe will use make_date to demonstrate a couple of\r\nscenarios where this function can fail and the methods to safeguard\r\nagainst such scenarios.\r\nScenario 1: Missing Arguments\r\nThe most basic check we should perform before running the function\r\nlogic is to confirm if all the required arguments are available. Think\r\nabout how your function should behave if one of the arguments, suppose\r\nmm is missing.\r\n\r\n\r\nmake_date(yyyy = 2022, dd = 31)\r\n\r\n\r\nError in paste(yyyy, mm, dd, sep = \"-\"): argument \"mm\" is missing, with no default\r\n\r\n\r\nNote that the error message shown to the user, is triggered, not from\r\nour function make_date but from the internal\r\npaste function. We do not have any control over what error\r\nmessages are shown when errors occur. In this case, we know specifically\r\nthat this error is due to a missing argument.\r\nThere are two ways to handle missing arguments:\r\n1.1 Early Exit\r\nIf a certain required argument is missing, we can stop the execution\r\nof the function and show informative error message about which argument\r\nis missing. Your friends here are the missing and\r\nstop functions. The missing function checks if\r\nthe given argument is missing or is set to NULL and returns TRUE, else\r\nit returns FALSE. The stop function stops the execution and\r\ndisplays the custom error message we provide. Using these functions\r\ninside an if condition will let us check for missing\r\narguments. Let us modify our naive function to stop early when required\r\narguments are missing.\r\n\r\n\r\nmake_date <-  function(yyyy, mm, dd) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy)) stop(\"argument `yyyy` is required.\")\r\n  if (missing(mm))   stop(\"argument `mm` is required.\")\r\n  if (missing(dd))   stop(\"argument `dd` is required.\")\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\n# Calling the function without `mm` argument\r\nmake_date(yyyy = 2022, dd = 31)\r\n\r\n\r\nError in make_date(yyyy = 2022, dd = 31): argument `mm` is required.\r\n\r\n\r\nNote that here, we add three if-missing-stop statements,\r\none for each required argument. We must do this if we want to display\r\nspecific error messages for each argument. There is another way to do\r\nthe same but we will look at it later. If we want to display a single\r\nerror message, we can do so by clubbing the missing\r\nfunctions inside an any which will return TRUE if any one\r\nof the arguments is missing. However, providing clear error messages\r\nbecomes challenging in this method.\r\n\r\n\r\ndummy_fun <- function(a, b, c) { \r\n  if(any(missing(a), missing(b), missing(c))) {\r\n    stop(\"One or more required arguments missing.\")\r\n  }\r\n  # Do something...\r\n}\r\ndummy_fun(a = 1)\r\n\r\n\r\nError in dummy_fun(a = 1): One or more required arguments missing.\r\n\r\n\r\n1.2 Sensible defaults with\r\nwarnings\r\nIn some cases, we may need the function to use some sensible default\r\nvalue for the required arguments and continue execution. Here, we\r\ndisplay a warning message instead of an error message. This is required\r\nwhen the argument value is either considered to be obvious or the\r\nargument is not necessarily the most important one and is used only in\r\nextreme customization. Providing default values to arguments\r\nmakes them optional arguments. An example of default argument\r\nvalues can be seen in the paste function we have used\r\nearlier. The default value of the separator argument sep is\r\na single whitespace character.\r\n\r\n\r\nargs(paste)\r\n\r\n\r\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \r\nNULL\r\n\r\nSimilarly, we can provide some sensible defaults for the\r\nmake_date function. Let’s modify the function further to\r\nprovide defaults for the mm and dd arguments\r\nonly.\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\n# Calling the function without `mm` and `dd` arguments\r\nmake_date(yyyy = 2022) # here, only `yyyy` is the required argument.\r\n\r\n\r\nWarning in make_date(yyyy = 2022): argument `mm` is missing. Using\r\ndefault value mm = 1 instead\r\n\r\nWarning in make_date(yyyy = 2022): argument `dd` is missing. Using\r\ndefault value dd = 1 instead\r\n\r\n[1] \"2022-01-01\"\r\n\r\nThere are a few concerns about using warnings instead of error\r\nmessages. Some are listed here in this article from RBloggers A\r\nWarning About warning.\r\nScenario 2: Invalid\r\nArgument Data Type\r\nWe have defined make_date to accept 3 numeric arguments\r\ni.e. all 3 must be numbers. What would happen if someone tried to call\r\nmake_date with character, factor or boolean inputs?\r\n\r\n\r\nmake_date(yyyy = \"2022\", mm = \"5\", dd = \"20\") # works!! why?\r\n\r\n\r\n[1] \"2022-05-20\"\r\n\r\nIn this case, the function works because when the arguments are\r\ncombined into a single string using paste , it matches the\r\nformat argument of the as.Date function in the\r\nmain logic of make_date which is\r\nas.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n\r\n\r\nmake_date(yyyy = \"2022\", mm = \"May\", dd = \"1\") # works but shows NA !!!\r\n\r\n\r\n[1] NA\r\n\r\nIn this case, all the arguments pass the checks but the output is\r\nNA since we pass 2022-May-1 to\r\nas.Date which doesn’t match the\r\nformat = '%Y-%m-%d'.\r\nHow do we check if the values provided to the arguments are numbers\r\nor number-like? If the values are numbers, we let them pass. But if they\r\nare non-numeric, we must check if they can be converted to numbers i.e.\r\nwe must check if they are number-like. By number-like, I mean, will\r\ncoercing the value using as.numeric give us a numeric value\r\nor NA ? You guessed it right, we will pass the values\r\nthrough as.numeric and check if the output is\r\nNA or not.\r\nWhat are the various data types in R that are not\r\nnumeric but can look like numbers? We have\r\ncharacter, factor and boolean\r\ndata types which can behave like numbers sometimes. Let’s see a few\r\nscenarios.\r\nCharacter arguments\r\n\r\n\r\nYear <- c(\"2022\", \"TwentyTwo\")\r\nYear_num <- as.numeric(Year) # this should show a warning about NAs introduced by coercion\r\nYear_num # must show the number 2022 without quotes and one NA\r\n\r\n\r\n[1] 2022   NA\r\n\r\nAs you can see in above example, when passed through\r\nas.numeric, the value “2022” gets converted to the number\r\n2022 but the value “TwentyTwo” does not. Hence we can say “2022” is\r\nnumber-like but “TwentyTwo” is not.\r\nFactor arguments\r\n\r\n\r\nYear <- factor(c(\"2022\",\"2021\",\"TwentyTwo\"))\r\nas.numeric(Year)\r\n\r\n\r\n[1] 2 1 3\r\n\r\nYearX <- factor(c(\"2022\", \"X\"))\r\nas.numeric(YearX)\r\n\r\n\r\n[1] 1 2\r\n\r\nYearY <- factor(2022)\r\nas.numeric(YearY)\r\n\r\n\r\n[1] 1\r\n\r\nAs you can see from above examples, factor values do get\r\nconverted to numeric but do not give the right results. So we can safely\r\nsay that factors are not number-like.\r\nI will ignore boolean data types hoping that useRs are\r\nbright enough to not use Booleans while creating a Date!\r\nFrom the above examples, we can conclude that numeric\r\nvalues and number-like character values are the only valid\r\ndata types that should be allowed. Modifying our make_date\r\nfunction to include data type checks.\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  # Check data types\r\n  if (!is.numeric(yyyy) & !is.character(yyyy)) {\r\n    stop(\"argument `yyyy` must be numeric\")\r\n  } else if (is.character(yyyy) & is.na(as.numeric(yyyy))) {\r\n    stop(\"argument `yyyy` must be numeric\")\r\n  }\r\n  if (!is.numeric(mm) & !is.character(mm)) {\r\n    stop(\"argument `mm` must be numeric\")\r\n  } else if (is.character(mm) & is.na(as.numeric(mm))) {\r\n    stop(\"argument `mm` must be numeric\")\r\n  }\r\n  if (!is.numeric(dd) & !is.character(dd)) {\r\n    stop(\"argument `dd` must be numeric\")\r\n  } else if (is.character(dd) & is.na(as.numeric(dd))) {\r\n    stop(\"argument `dd` must be numeric\")\r\n  }\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\n# Calling the function with new datatype checks\r\nmake_date(yyyy = \"2022\", mm = \"May\", dd = \"1\")\r\n\r\n\r\nError in make_date(yyyy = \"2022\", mm = \"May\", dd = \"1\"): argument `mm` must be numeric\r\n\r\n\r\nmake_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\")\r\n\r\n\r\nError in make_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\"): argument `mm` must be numeric\r\n\r\n\r\nNotice that the datatype check is lengthy and similar for all 3\r\narguments. We can apply DRY principle again and\r\nencapsulate that code into a small function is_numberlike\r\nwhich will return TRUE or FALSE . Note that\r\nis_numberlike has no checks because it is an internal\r\nfunction.\r\n\r\n\r\n# This function check if value is number or number-like.\r\nis_numberlike <- function(x){\r\n  if (!is.numeric(x) & !is.character(x)) {\r\n    return(FALSE) # Early Exit 1 if value is neither numeric nor character\r\n  } else if (is.character(x) & is.na(as.numeric(x))) {\r\n    return(FALSE) # Early Exit 2 if character value is not number-like.\r\n  }\r\n  return(TRUE)\r\n}\r\n\r\n\r\n\r\nThus our make_date function with data types check will\r\nlook as below.\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  # Check data types\r\n  if (!is_numberlike(yyyy)) stop(\"argument `yyyy` must be numeric\")\r\n  if (!is_numberlike(mm))   stop(\"argument `mm` must be numeric\")\r\n  if (!is_numberlike(dd))   stop(\"argument `dd` must be numeric\")\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\n# Calling the function with new datatype checks\r\nmake_date(yyyy = \"TwentyTwo\", mm = \"5\", dd = 1)\r\n\r\n\r\nWarning in is_numberlike(yyyy): NAs introduced by coercion\r\n\r\nError in make_date(yyyy = \"TwentyTwo\", mm = \"5\", dd = 1): argument `yyyy` must be numeric\r\n\r\n\r\nmake_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\")\r\n\r\n\r\nError in make_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\"): argument `mm` must be numeric\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 5, dd = \"one\")\r\n\r\n\r\nWarning in is_numberlike(dd): NAs introduced by coercion\r\n\r\nError in make_date(yyyy = 2022, mm = 5, dd = \"one\"): argument `dd` must be numeric\r\n\r\n\r\nOne of the most interesting features of R is vectorization! Due to\r\nthis feature, our function make_date behaves in interesting\r\nways. In some cases, it is desirable and sometimes it is not.\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 1:12, dd = \"1\")\r\n\r\n\r\n [1] \"2022-01-01\" \"2022-02-01\" \"2022-03-01\" \"2022-04-01\" \"2022-05-01\"\r\n [6] \"2022-06-01\" \"2022-07-01\" \"2022-08-01\" \"2022-09-01\" \"2022-10-01\"\r\n[11] \"2022-11-01\" \"2022-12-01\"\r\n\r\nNote the above warnings. These warnings appear because the\r\nif statement checks if the condition provided results in a\r\nsingle TRUE or FALSE value. However, the\r\noutput of the check is.na(as.numeric(mm)) is a boolean\r\nvector of length 12. But if needs only 1 TRUE\r\nor FALSE.\r\nThe output contains 12 date values since paste is\r\nvectorised, it recycles the values for yyyy and\r\ndd to give us 12 dates!\r\n\r\n\r\nmm <- 1:12\r\npaste(\"Month\", mm)\r\n\r\n\r\n [1] \"Month 1\"  \"Month 2\"  \"Month 3\"  \"Month 4\"  \"Month 5\"  \"Month 6\" \r\n [7] \"Month 7\"  \"Month 8\"  \"Month 9\"  \"Month 10\" \"Month 11\" \"Month 12\"\r\n\r\nWhat do we do if we want make_date to return just one\r\ndate?\r\nScenario 3: Incorrect\r\nArgument Size\r\nTo ensure make_date gives you just one date, we must\r\nensure that the arguments have just value and is not a vector of\r\nmultiple values i.e. length(arg)==1. Let’s further add a\r\nfew checks for the data size of the arguments and rearrange the\r\nchecks.\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  # Check argument lengths\r\n  if (length(yyyy)!=1) stop(paste0(\"Length of argument `yyyy` is \", length(yyyy),\". Must be only 1.\"))\r\n  if (length(mm)!=1)   stop(paste0(\"Length of argument `mm` is \", length(mm),\". Must be only 1.\"))\r\n  if (length(dd)!=1)   stop(paste0(\"Length of argument `dd` is \", length(dd),\". Must be only 1.\"))\r\n  \r\n  # Check data types\r\n  if (!is_numberlike(yyyy)) stop(\"argument `yyyy` must be numeric\")\r\n  if (!is_numberlike(mm))   stop(\"argument `mm` must be numeric\")\r\n  if (!is_numberlike(dd))   stop(\"argument `dd` must be numeric\")\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\n# Calling function with new data size checks\r\nmake_date(yyyy = 2022, mm = 1:12, dd = \"01\")\r\n\r\n\r\nError in make_date(yyyy = 2022, mm = 1:12, dd = \"01\"): Length of argument `mm` is 12. Must be only 1.\r\n\r\n\r\nmake_date(yyyy = c(\"2021\",\"2022\"), mm = \"1\", dd = 1)\r\n\r\n\r\nError in make_date(yyyy = c(\"2021\", \"2022\"), mm = \"1\", dd = 1): Length of argument `yyyy` is 2. Must be only 1.\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 1, dd = c(\"1\",\"2\"))\r\n\r\n\r\nError in make_date(yyyy = 2022, mm = 1, dd = c(\"1\", \"2\")): Length of argument `dd` is 2. Must be only 1.\r\n\r\n\r\nA little detour…\r\nSo far we checked for missing arguments, arguments with bad data\r\ntypes and arguments with incorrect sizes. We’ve used the\r\nstop function along with if to check for all\r\nfailure conditions and show appropriate error messages. When we use\r\nstop, we must specify all the failure conditions and the\r\nnumber of specific error messages goes up as number of arguments\r\nincreases.\r\nIn case of our make_date, if an argument is not missing,\r\nit must be a number-like value of length 1. To reduce the number of\r\nerror messages, we can combine the error messages for data type and\r\nlength. for eg, the error message could be argument\r\nyyyy must be a number-like value of length 1.\r\nWouldn’t it be easier if we just specify what is the success\r\ncondition aka the “happy path”, and show error for all other conditions?\r\nTo do this, we can use the stopifnot function that let’s us\r\nspecify all the happy paths. See example below.\r\n\r\n\r\ndummy_sum <- function(a, b, c){\r\n  \r\n  # check missing\r\n  stopifnot(!missing(a) & !missing(b) & !missing(c))\r\n  \r\n  # check argument values\r\n  stopifnot(!is.na(a) & is.numeric(a) & length(a)==1,\r\n            !is.na(b) & is.numeric(b) & length(b)==1,\r\n            !is.na(c) & is.numeric(c) & length(c)==1\r\n            )\r\n  sum(a, b, c)\r\n}\r\n\r\ndummy_sum(b = 2, c = 3) # a is missing\r\n\r\n\r\nError in dummy_sum(b = 2, c = 3): !missing(a) & !missing(b) & !missing(c) is not TRUE\r\n\r\n\r\ndummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value\r\n\r\n\r\nError in dummy_sum(a = NA_integer_, b = 2, c = 3): !is.na(a) & is.numeric(a) & length(a) == 1 is not TRUE\r\n\r\n\r\ndummy_sum(a = 1, b = \"2\", c = 3) # b has non-numeric value\r\n\r\n\r\nError in dummy_sum(a = 1, b = \"2\", c = 3): !is.na(b) & is.numeric(b) & length(b) == 1 is not TRUE\r\n\r\n\r\ndummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1\r\n\r\n\r\nError in dummy_sum(a = 1, b = 2, c = 5:7): !is.na(c) & is.numeric(c) & length(c) == 1 are not all TRUE\r\n\r\n\r\nNote the error messages above. They are not so user-friendly.\r\nLuckily, we can specify error messages in stopifnot by\r\nproviding the error messages as the names of the “happy path”\r\nconditions.\r\n\r\n\r\ndummy_sum <- function(a, b, c){\r\n  \r\n  # check missing\r\n  stopifnot(\"one or more required arguments missing\" = !missing(a) & !missing(b) & !missing(c))\r\n  \r\n  # check argument values\r\n  stopifnot(\"argument `a` must not be NA, must be a number of length 1\" = !is.na(a) & is.numeric(a) & length(a)==1,\r\n            \"argument `b` must not be NA, must be a number of length 1\" = !is.na(b) & is.numeric(b) & length(b)==1,\r\n            \"argument `c` must not be NA, must be a number of length 1\" = !is.na(c) & is.numeric(c) & length(c)==1\r\n            )\r\n  sum(a, b, c)\r\n}\r\n\r\ndummy_sum(b = 2, c = 3) # a is missing\r\n\r\n\r\nError in dummy_sum(b = 2, c = 3): one or more required arguments missing\r\n\r\n\r\ndummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value\r\n\r\n\r\nError in dummy_sum(a = NA_integer_, b = 2, c = 3): argument `a` must not be NA, must be a number of length 1\r\n\r\n\r\ndummy_sum(a = 1, b = \"2\", c = 3) # b has non-numeric value\r\n\r\n\r\nError in dummy_sum(a = 1, b = \"2\", c = 3): argument `b` must not be NA, must be a number of length 1\r\n\r\n\r\ndummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1\r\n\r\n\r\nError in dummy_sum(a = 1, b = 2, c = 5:7): argument `c` must not be NA, must be a number of length 1\r\n\r\n\r\nUsing stopifnot in our make_date function\r\nto combine the datatype and length checks, we get…\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  \r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  \r\n  # Check argument types and length\r\n  stopifnot(\r\n    \"argument `yyyy` must be numeric with length 1\" = is_numberlike(yyyy) & length(yyyy)==1,\r\n    \"argument `mm` must be numeric with length 1\"   = is_numberlike(mm)   & length(mm)==1,\r\n    \"argument `dd` must be numeric with length 1\"   = is_numberlike(dd)   & length(dd)==1\r\n  )\r\n  \r\n  # main logic\r\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n}\r\n\r\nmake_date() # no arguments provided\r\n\r\n\r\nError in make_date(): argument `yyyy` is required.\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 1:12, dd = 31) # Length mm not equal to 1\r\n\r\n\r\nWarning in if (is.character(x) & is.na(as.numeric(x))) {: the\r\ncondition has length > 1 and only the first element will be used\r\n\r\nError in make_date(yyyy = 2022, mm = 1:12, dd = 31): argument `mm` must be numeric with length 1\r\n\r\n\r\nmake_date(yyyy = 2022, mm = \"Jan\", dd = 31) # mm is not number-like\r\n\r\n\r\nWarning in is_numberlike(mm): NAs introduced by coercion\r\n\r\nError in make_date(yyyy = 2022, mm = \"Jan\", dd = 31): argument `mm` must be numeric with length 1\r\n\r\n\r\nmake_date(yyyy = 2022, dd = 31) # argument mm is missing but should work using default value\r\n\r\n\r\nWarning in make_date(yyyy = 2022, dd = 31): argument `mm` is missing.\r\nUsing default value mm = 1 instead\r\n\r\n[1] \"2022-01-31\"\r\n\r\nScenario\r\n4: Values of Arguments that result in invalid outputs\r\nFinally, what do we do when the arguments provided will definitely\r\ngive us bad results despite passing all checks? In our case,\r\nmake_date creates a date but if we give it values that will\r\nresult in an invalid date, it will give us invalid results (remember\r\nGarbage-In-Garbage-Out?).\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?\r\n\r\n\r\n[1] NA\r\n\r\nWe get NA because as.Date returns NA for\r\ninvalid inputs with no error messages or warnings! We can check the\r\noutput and provide a generic error message.\r\n\r\n\r\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\r\n  # check missing arguments\r\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \r\n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \r\n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\r\n  \r\n  \r\n  # Check argument types and length\r\n  stopifnot(\r\n    \"argument `yyyy` must be numeric with length 1\" = is_numberlike(yyyy) & length(yyyy)==1,\r\n    \"argument `mm` must be numeric with length 1\"   = is_numberlike(mm)   & length(mm)==1,\r\n    \"argument `dd` must be numeric with length 1\"   = is_numberlike(dd)   & length(dd)==1\r\n  )\r\n  \r\n  # main logic\r\n  out <- as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\r\n  if (is.na(out)) {\r\n    stop(\"Invalid values provided. Please check your inputs.\")\r\n  }\r\n  return(out)\r\n}\r\n\r\nmake_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?\r\n\r\n\r\nError in make_date(yyyy = 2022, mm = 13, dd = 1): Invalid values provided. Please check your inputs.\r\n\r\n\r\nmake_date(yyyy = 2022, mm = 2, dd = 31) # are there 31 days in February?\r\n\r\n\r\nError in make_date(yyyy = 2022, mm = 2, dd = 31): Invalid values provided. Please check your inputs.\r\n\r\n\r\nDo you think our function make_date is robust\r\nenough?\r\nAs robust as Superman! Source:\r\nTumblrConclusion\r\nMaking functions robust requires some prior thought about its\r\nintended use and audience. Based on this, we can decide what checks to\r\nimplement, what to skip, whether to stop execution using error messages\r\nor to use default values with warnings. Checking for “happy paths” is\r\nsimpler compared to checking each and every bad input and providing\r\nspecific error messages. Too many different error messages for the same\r\nargument could become a source of frustration of the end user, so\r\nconsider combining some checks and their error messages to be\r\ninformative and precise. Robustness, like everything else, in\r\nmoderation, is good and getting it “just right” takes time and dedicated\r\neffort. Happy Coding!\r\nCitations & References\r\nTechniques for\r\nwriting robust R programs - LexJansen\r\nR\r\nProgramming for Data Science\r\nA\r\nWarning About warning\r\n\r\n\r\n\r\n",
    "preview": "https://64.media.tumblr.com/f6dc1e64c3d63e1f308e46445cafb6ab/tumblr_mo7km0eiRW1qedb29o1_500.gif",
    "last_modified": "2022-05-04T20:39:56+05:30",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-29-rtovbatoppt/",
    "title": "Unholy Trinity of R, Excel VBA and Powerpoint - Part 2 of 2",
    "description": "Using R to trigger Excel VBA macros to create PowerPoint presentations!",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2021-12-29",
    "categories": [
      "Rstats",
      "Excel",
      "VBA",
      "PowerPoint",
      "openxlsx",
      "RDCOMClient"
    ],
    "contents": "\r\n\r\nContents\r\nQuick Recap\r\nStrategy\r\nCreating the datasets\r\nSlide 1\r\nSlide 2\r\nSlide 3\r\n\r\nThe for loop!\r\nReferences & Citations\r\n\r\nThis is part 2 of 2. Read part 1 here.\r\nQuick Recap\r\nIn the previous post, we create the .potx template from the .pptx file we wanted to automate and the Excel template with the macro .xlsm that uses the PowerPoint template to create a new .pptx file with given data using VBA.\r\nThe report we want to automate is…\r\nThe Gapminder Report : The PowerPoint presentation we want to automate…and the Excel and PowerPoint template we created are shown below.\r\nExcel Template with VBA macroIn this post, we will write the R script that will first massage the data into desired format and then load the data for one region into the Excel template and execute the VBA macro that will create the PowerPoint file with that data.\r\nStrategy\r\nBefore we dive into code, we need to check a few things. We wish to create a presentation for each continent in the Gapminder data. A closer look at the Presentation will tell you what kind of data we need for each slide/graph/table while the Excel template will reveal what should the structure of each dataset should be. While looking into this structure, some questions will pop-up. The idea here is to create the datasets in such a way that they can be easily filtered for each continent and the resultant table can be written to the Excel template without any or very little modification. Let us proceed slide-by-slide.\r\nCreating the datasets\r\nSlide 1\r\nSlide 1 is the title page and needs 2 strings; one for Title, one for Subtitle. The Title for the base presentation is “World Population”. For each continent, it could be “<continent_name> Population”. The subtitle is a combination of Author Name and Created Date. So we need a string like “<author_name> | <created_date>” where created_date is the formatted system date.\r\nThese strings can be created while writing the data to the Excel template.\r\nSlide 2\r\nThe chart on slide 2 needs raw data structured as below. You will notice that at a continent-level, this table needs a minimum of 5 countries. Do we have any continents in the Gapminder data with less than 5 countries? Yes, we have Oceania with only Australia and New Zealand. For ease of use, let us include these countries along with Asian countries in a new Region variable.\r\n02_chartWe will create the region variable in the gapminder data. But first, let us load some relevant packages.\r\n\r\n\r\noptions(tidyverse.quiet = TRUE)\r\nlibrary(tidyverse) # duh!\r\nlibrary(reactable) # to display the tables interactively in this post. Not really needed for the final solution.\r\nlibrary(openxlsx) # to write the data to the Excel Template.\r\nlibrary(RDCOMClient) # to load and run the Excel macro post data load.\r\n\r\n\r\n\r\n\r\n\r\n# Read in Gapminder data\r\ngp <- gapminder::gapminder\r\n\r\n# Create new region variable\r\ngp <- gp %>%\r\n  mutate(region = if_else(as.character(continent) %in% c(\"Asia\",\"Oceania\"),\r\n                          \"Asia-Pacific\", \r\n                          as.character(continent)),\r\n         country = as.character(country))\r\n\r\n# Keep only relevant columns\r\ngp <- gp %>% select(region, country, year, pop)\r\n\r\n# View details\r\nglimpse(gp)\r\n\r\n\r\nRows: 1,704\r\nColumns: 4\r\n$ region  <chr> \"Asia-Pacific\", \"Asia-Pacific\", \"Asia-Pacific\", \"Asi~\r\n$ country <chr> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghan~\r\n$ year    <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992~\r\n$ pop     <int> 8425333, 9240934, 10267083, 11537966, 13079460, 1488~\r\n\r\nNow that we have the source data available, we must now create the datasets we need that we can write to the Excel template for each region.\r\nThe required table shows the top 4 countries (based on 2007 population) and all other countries clubbed into ‘others’ in a given region and then the total population of the region on a yearly basis. This table has to be created for all 4 regions.\r\n\r\n\r\npop_trend <- gp %>%\r\n  group_by(region, country, year) %>% \r\n  summarise(pop = sum(pop, na.rm = TRUE),\r\n            .groups = 'drop') %>%\r\n  mutate(pop = round(pop/1E6, 0)) %>% # population in millions\r\n  pivot_wider(names_from = year, values_from = pop, names_sort = TRUE) %>% \r\n  arrange(desc(`2007`)) # sort by max pop to min pop in latest year i.e. 2007\r\n\r\nreactable(pop_trend, compact=TRUE,\r\n                     style = \"font-size:12px\")\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"region\":[\"Asia-Pacific\",\"Asia-Pacific\",\"Americas\",\"Asia-Pacific\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Africa\",\"Asia-Pacific\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Africa\",\"Africa\",\"Europe\",\"Asia-Pacific\",\"Africa\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Asia-Pacific\",\"Asia-Pacific\",\"Africa\",\"Americas\",\"Africa\",\"Americas\",\"Europe\",\"Europe\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Asia-Pacific\",\"Africa\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Americas\",\"Asia-Pacific\",\"Africa\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Africa\",\"Asia-Pacific\",\"Asia-Pacific\",\"Africa\",\"Asia-Pacific\",\"Africa\",\"Africa\",\"Europe\",\"Americas\",\"Africa\",\"Americas\",\"Asia-Pacific\",\"Africa\",\"Africa\",\"Americas\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Europe\",\"Europe\",\"Africa\",\"Africa\",\"Africa\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Americas\",\"Europe\",\"Africa\",\"Africa\",\"Europe\",\"Europe\",\"Americas\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Europe\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Africa\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Europe\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Asia-Pacific\",\"Europe\",\"Africa\",\"Africa\",\"Europe\"],\"country\":[\"China\",\"India\",\"United States\",\"Indonesia\",\"Brazil\",\"Pakistan\",\"Bangladesh\",\"Nigeria\",\"Japan\",\"Mexico\",\"Philippines\",\"Vietnam\",\"Germany\",\"Egypt\",\"Ethiopia\",\"Turkey\",\"Iran\",\"Congo, Dem. Rep.\",\"Thailand\",\"France\",\"United Kingdom\",\"Italy\",\"Korea, Rep.\",\"Myanmar\",\"South Africa\",\"Colombia\",\"Sudan\",\"Argentina\",\"Spain\",\"Poland\",\"Tanzania\",\"Kenya\",\"Morocco\",\"Algeria\",\"Canada\",\"Afghanistan\",\"Uganda\",\"Peru\",\"Nepal\",\"Saudi Arabia\",\"Iraq\",\"Venezuela\",\"Malaysia\",\"Ghana\",\"Korea, Dem. Rep.\",\"Taiwan\",\"Yemen, Rep.\",\"Romania\",\"Mozambique\",\"Australia\",\"Sri Lanka\",\"Madagascar\",\"Syria\",\"Cameroon\",\"Cote d'Ivoire\",\"Netherlands\",\"Chile\",\"Burkina Faso\",\"Ecuador\",\"Cambodia\",\"Malawi\",\"Niger\",\"Guatemala\",\"Angola\",\"Mali\",\"Senegal\",\"Zambia\",\"Zimbabwe\",\"Cuba\",\"Greece\",\"Portugal\",\"Chad\",\"Guinea\",\"Tunisia\",\"Belgium\",\"Czech Republic\",\"Hungary\",\"Serbia\",\"Rwanda\",\"Somalia\",\"Bolivia\",\"Dominican Republic\",\"Haiti\",\"Sweden\",\"Benin\",\"Burundi\",\"Austria\",\"Switzerland\",\"El Salvador\",\"Honduras\",\"Paraguay\",\"Hong Kong, China\",\"Bulgaria\",\"Libya\",\"Sierra Leone\",\"Togo\",\"Nicaragua\",\"Israel\",\"Jordan\",\"Eritrea\",\"Singapore\",\"Bosnia and Herzegovina\",\"Denmark\",\"Finland\",\"Norway\",\"Slovak Republic\",\"Central African Republic\",\"Congo, Rep.\",\"Costa Rica\",\"Puerto Rico\",\"Lebanon\",\"New Zealand\",\"West Bank and Gaza\",\"Albania\",\"Croatia\",\"Ireland\",\"Liberia\",\"Mauritania\",\"Jamaica\",\"Panama\",\"Uruguay\",\"Kuwait\",\"Mongolia\",\"Oman\",\"Botswana\",\"Gambia\",\"Lesotho\",\"Namibia\",\"Slovenia\",\"Comoros\",\"Equatorial Guinea\",\"Gabon\",\"Guinea-Bissau\",\"Mauritius\",\"Reunion\",\"Swaziland\",\"Trinidad and Tobago\",\"Bahrain\",\"Montenegro\",\"Djibouti\",\"Sao Tome and Principe\",\"Iceland\"],\"1952\":[556,372,158,82,57,41,47,33,86,30,22,26,69,22,21,22,17,14,21,42,50,48,21,20,14,12,9,18,29,26,8,6,10,9,15,8,6,8,9,4,5,5,7,6,9,9,5,17,6,9,8,5,4,5,3,10,6,4,4,5,3,3,3,4,4,3,3,3,6,8,9,3,3,4,9,9,10,7,3,3,3,2,3,7,2,2,7,5,2,2,2,2,7,1,2,1,1,2,1,1,1,3,4,4,3,4,1,1,1,2,1,2,1,1,4,3,1,1,1,1,2,0,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0],\"1957\":[637,409,172,90,66,47,51,37,92,35,26,29,71,25,23,26,20,16,25,44,51,49,23,22,16,14,10,20,30,28,9,7,11,10,17,9,7,9,10,4,6,7,8,6,9,10,5,18,7,10,9,5,4,5,3,11,7,5,4,5,3,4,4,5,4,3,3,4,7,8,9,3,3,4,9,10,10,7,3,3,3,3,4,7,2,3,7,5,2,2,2,3,8,1,2,1,1,2,1,2,1,3,4,4,3,4,1,1,1,2,2,2,1,1,4,3,1,1,2,1,2,0,1,1,0,0,1,1,2,0,0,0,1,1,0,0,1,0,0,0,0,0],\"1962\":[666,454,187,99,76,53,57,42,96,41,30,34,74,28,25,30,23,17,29,47,53,51,26,24,18,17,11,21,31,30,11,9,13,11,19,10,8,11,10,5,7,8,9,7,11,12,6,19,8,11,10,6,5,6,4,12,8,5,5,6,4,4,4,5,5,3,3,4,7,8,9,3,3,4,9,10,10,8,3,3,4,3,4,8,2,3,7,6,3,2,2,3,8,1,2,2,2,2,1,2,2,3,5,4,4,4,2,1,1,2,2,2,1,2,4,3,1,1,2,1,3,0,1,1,1,0,1,1,2,0,0,0,1,1,0,0,1,0,0,0,0,0],\"1967\":[755,506,199,109,88,61,63,47,101,48,35,39,76,32,28,33,27,20,34,50,55,53,30,26,21,20,13,23,33,32,13,10,15,13,21,12,9,12,11,6,9,10,10,8,13,14,7,19,9,12,12,6,6,6,5,13,9,5,5,7,4,5,5,5,5,4,4,5,8,9,9,3,3,5,10,10,10,8,3,3,4,4,4,8,2,3,7,6,3,3,2,4,8,2,3,2,2,3,1,2,2,4,5,5,4,4,2,1,2,3,2,3,1,2,4,3,1,1,2,1,3,1,1,1,1,0,1,1,2,0,0,0,1,1,0,0,1,0,1,0,0,0],\"1972\":[862,567,210,121,101,69,71,54,107,56,41,45,79,35,31,37,31,23,39,52,56,54,34,28,24,23,15,25,35,33,15,12,17,15,22,13,10,14,12,6,10,12,11,9,15,15,7,21,10,13,13,7,7,7,6,13,10,5,6,7,5,5,5,6,6,5,5,6,9,9,9,4,4,5,10,10,10,8,4,4,5,5,5,8,3,4,8,6,4,3,3,4,9,2,3,2,2,3,2,2,2,4,5,5,4,5,2,1,2,3,3,3,1,2,4,3,1,1,2,2,3,1,1,1,1,1,1,1,2,0,0,1,1,1,0,0,1,0,1,0,0,0],\"1977\":[943,634,220,137,114,78,80,62,114,64,47,51,78,39,35,42,35,26,44,53,56,56,36,32,27,25,17,27,36,35,17,15,18,17,24,15,11,16,14,8,12,14,13,11,16,17,8,22,11,14,14,8,8,8,7,14,11,6,7,7,6,6,6,6,6,5,5,7,10,9,10,4,4,6,10,10,11,9,5,4,5,5,5,8,3,4,8,6,4,3,3,5,9,3,3,2,3,3,2,3,2,4,5,5,4,5,2,2,2,3,3,3,1,3,4,3,2,1,2,2,3,1,2,1,1,1,1,1,2,0,0,1,1,1,0,1,1,0,1,0,0,0],\"1982\":[1000,708,232,153,129,91,93,73,118,72,53,56,78,46,38,47,43,31,49,54,56,57,39,35,31,28,20,29,38,36,20,18,20,20,25,13,13,18,16,11,14,16,14,11,18,19,10,22,13,15,15,9,9,9,9,14,11,7,8,7,7,6,6,7,7,6,6,8,10,10,10,5,5,7,10,10,11,9,6,6,6,6,5,8,4,5,8,6,4,4,3,5,9,3,3,3,3,4,2,3,3,4,5,5,4,5,2,2,2,3,3,3,1,3,4,3,2,2,2,2,3,1,2,1,1,1,1,1,2,0,0,1,1,1,1,1,1,0,1,0,0,0],\"1987\":[1084,788,243,169,143,105,104,82,122,80,60,63,78,53,43,53,52,35,53,56,57,57,42,38,36,31,25,32,39,38,23,21,23,23,27,14,15,20,18,15,17,18,16,14,19,20,11,23,13,16,16,11,11,11,11,15,12,8,10,8,8,7,7,8,8,7,7,9,10,10,10,5,6,8,10,10,11,9,6,7,6,7,6,8,4,5,8,7,5,4,4,6,9,4,4,3,3,4,3,3,3,4,5,5,4,5,3,2,3,3,3,3,2,3,4,4,2,2,2,2,3,2,2,2,1,1,2,1,2,0,0,1,1,1,1,1,1,0,1,0,0,0],\"1992\":[1165,872,257,185,156,120,114,93,124,88,67,70,81,59,52,58,60,42,57,57,58,57,44,41,40,34,28,34,40,38,27,25,26,26,29,16,18,22,20,17,18,20,18,16,21,21,13,23,13,17,18,12,13,12,13,15,14,9,11,10,10,8,8,9,8,8,8,11,11,10,10,6,7,9,10,10,10,10,7,6,7,7,6,9,5,6,8,7,5,5,4,6,9,4,4,4,4,5,4,4,3,4,5,5,4,5,3,2,3,4,3,3,2,3,4,4,2,2,2,2,3,1,2,2,1,1,2,2,2,0,0,1,1,1,1,1,1,1,1,0,0,0],\"1997\":[1230,959,273,199,169,136,123,106,126,96,75,76,82,66,60,63,63,48,60,59,59,57,46,43,43,38,32,36,40,39,31,28,29,29,30,22,21,25,23,21,21,22,20,18,22,22,16,23,17,19,19,14,15,14,15,16,15,10,12,12,10,10,10,10,9,10,9,11,11,11,10,8,8,9,10,10,10,10,7,7,8,8,7,9,6,6,8,7,6,6,5,6,8,5,5,4,5,6,5,4,4,4,5,5,4,5,4,3,4,4,3,4,3,3,4,4,2,2,3,3,3,2,2,2,2,1,2,2,2,1,0,1,1,1,1,1,1,1,1,0,0,0],\"2002\":[1280,1034,288,211,180,153,136,120,127,102,83,81,82,73,68,67,67,55,63,60,60,58,48,46,44,41,37,38,40,39,35,31,31,31,32,25,25,27,26,25,24,24,23,21,22,22,19,22,18,20,20,16,17,16,16,16,15,12,13,13,12,11,11,11,11,11,11,12,11,11,10,9,9,10,10,10,10,10,8,8,8,9,8,9,7,7,8,7,6,7,6,7,8,5,5,5,5,6,5,4,4,4,5,5,5,5,4,3,4,4,4,4,3,4,4,4,3,3,3,3,3,2,3,3,2,1,2,2,2,1,0,1,1,1,1,1,1,1,1,0,0,0],\"2007\":[1319,1110,301,224,190,169,150,135,127,109,91,85,82,80,77,71,69,65,65,61,61,58,49,48,44,44,42,40,40,39,38,36,34,33,33,32,29,29,29,28,27,26,25,23,23,23,22,22,20,20,20,19,19,18,18,17,16,14,14,14,13,13,13,12,12,12,12,12,11,11,11,10,10,10,10,10,10,10,9,9,9,9,9,9,8,8,8,8,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0]},\"columns\":[{\"accessor\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"accessor\":\"country\",\"name\":\"country\",\"type\":\"character\"},{\"accessor\":\"1952\",\"name\":\"1952\",\"type\":\"numeric\"},{\"accessor\":\"1957\",\"name\":\"1957\",\"type\":\"numeric\"},{\"accessor\":\"1962\",\"name\":\"1962\",\"type\":\"numeric\"},{\"accessor\":\"1967\",\"name\":\"1967\",\"type\":\"numeric\"},{\"accessor\":\"1972\",\"name\":\"1972\",\"type\":\"numeric\"},{\"accessor\":\"1977\",\"name\":\"1977\",\"type\":\"numeric\"},{\"accessor\":\"1982\",\"name\":\"1982\",\"type\":\"numeric\"},{\"accessor\":\"1987\",\"name\":\"1987\",\"type\":\"numeric\"},{\"accessor\":\"1992\",\"name\":\"1992\",\"type\":\"numeric\"},{\"accessor\":\"1997\",\"name\":\"1997\",\"type\":\"numeric\"},{\"accessor\":\"2002\",\"name\":\"2002\",\"type\":\"numeric\"},{\"accessor\":\"2007\",\"name\":\"2007\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"compact\":true,\"style\":{\"font-size\":\"12px\"},\"dataKey\":\"8faf5e6dd35f4347778f43ed027c4324\",\"key\":\"8faf5e6dd35f4347778f43ed027c4324\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nNow that we have the required columns, let’s plan the row order. We notice that, for each region, we have the top 4 countries (as per 2007) , followed by ‘Others’. Let’s create the top-4 dataset.\r\n\r\n\r\ntop4 <- pop_trend %>% \r\n  group_by(region) %>% \r\n  slice_max(`2007`, n = 4, with_ties = FALSE) %>% \r\n  ungroup()\r\n\r\nreactable(top4, compact=TRUE, style = \"font-size:12px\")\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"region\":[\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Europe\"],\"country\":[\"Nigeria\",\"Egypt\",\"Ethiopia\",\"Congo, Dem. Rep.\",\"United States\",\"Brazil\",\"Mexico\",\"Colombia\",\"China\",\"India\",\"Indonesia\",\"Pakistan\",\"Germany\",\"Turkey\",\"France\",\"United Kingdom\"],\"1952\":[33,22,21,14,158,57,30,12,556,372,82,41,69,22,42,50],\"1957\":[37,25,23,16,172,66,35,14,637,409,90,47,71,26,44,51],\"1962\":[42,28,25,17,187,76,41,17,666,454,99,53,74,30,47,53],\"1967\":[47,32,28,20,199,88,48,20,755,506,109,61,76,33,50,55],\"1972\":[54,35,31,23,210,101,56,23,862,567,121,69,79,37,52,56],\"1977\":[62,39,35,26,220,114,64,25,943,634,137,78,78,42,53,56],\"1982\":[73,46,38,31,232,129,72,28,1000,708,153,91,78,47,54,56],\"1987\":[82,53,43,35,243,143,80,31,1084,788,169,105,78,53,56,57],\"1992\":[93,59,52,42,257,156,88,34,1165,872,185,120,81,58,57,58],\"1997\":[106,66,60,48,273,169,96,38,1230,959,199,136,82,63,59,59],\"2002\":[120,73,68,55,288,180,102,41,1280,1034,211,153,82,67,60,60],\"2007\":[135,80,77,65,301,190,109,44,1319,1110,224,169,82,71,61,61]},\"columns\":[{\"accessor\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"accessor\":\"country\",\"name\":\"country\",\"type\":\"character\"},{\"accessor\":\"1952\",\"name\":\"1952\",\"type\":\"numeric\"},{\"accessor\":\"1957\",\"name\":\"1957\",\"type\":\"numeric\"},{\"accessor\":\"1962\",\"name\":\"1962\",\"type\":\"numeric\"},{\"accessor\":\"1967\",\"name\":\"1967\",\"type\":\"numeric\"},{\"accessor\":\"1972\",\"name\":\"1972\",\"type\":\"numeric\"},{\"accessor\":\"1977\",\"name\":\"1977\",\"type\":\"numeric\"},{\"accessor\":\"1982\",\"name\":\"1982\",\"type\":\"numeric\"},{\"accessor\":\"1987\",\"name\":\"1987\",\"type\":\"numeric\"},{\"accessor\":\"1992\",\"name\":\"1992\",\"type\":\"numeric\"},{\"accessor\":\"1997\",\"name\":\"1997\",\"type\":\"numeric\"},{\"accessor\":\"2002\",\"name\":\"2002\",\"type\":\"numeric\"},{\"accessor\":\"2007\",\"name\":\"2007\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"compact\":true,\"style\":{\"font-size\":\"12px\"},\"dataKey\":\"20a2fa7ddabed27d7921edb0c84bba8e\",\"key\":\"20a2fa7ddabed27d7921edb0c84bba8e\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nTo create the others dataset, we exclude all countries that are present in the top-4.\r\n\r\n\r\nothers <- pop_trend %>% \r\n  filter(!country %in% top4$country) %>% \r\n  group_by(region) %>% \r\n  summarise(across(.cols = -country, .fns = sum),\r\n            .groups = 'drop') %>% \r\n  mutate(country = \"Others\") %>% \r\n  select(region, country, everything())\r\n\r\nreactable(others, compact=TRUE, style = \"font-size:12px\")\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"region\":[\"Africa\",\"Americas\",\"Asia-Pacific\",\"Europe\"],\"country\":[\"Others\",\"Others\",\"Others\",\"Others\"],\"1952\":[146,88,354,235],\"1957\":[162,101,391,244],\"1962\":[183,113,436,257],\"1967\":[206,127,493,269],\"1972\":[239,143,546,278],\"1977\":[270,156,608,289],\"1982\":[314,167,672,294],\"1987\":[362,185,745,301],\"1992\":[409,202,811,303],\"1997\":[463,224,882,305],\"2002\":[515,238,949,307],\"2007\":[570,254,1012,310]},\"columns\":[{\"accessor\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"accessor\":\"country\",\"name\":\"country\",\"type\":\"character\"},{\"accessor\":\"1952\",\"name\":\"1952\",\"type\":\"numeric\"},{\"accessor\":\"1957\",\"name\":\"1957\",\"type\":\"numeric\"},{\"accessor\":\"1962\",\"name\":\"1962\",\"type\":\"numeric\"},{\"accessor\":\"1967\",\"name\":\"1967\",\"type\":\"numeric\"},{\"accessor\":\"1972\",\"name\":\"1972\",\"type\":\"numeric\"},{\"accessor\":\"1977\",\"name\":\"1977\",\"type\":\"numeric\"},{\"accessor\":\"1982\",\"name\":\"1982\",\"type\":\"numeric\"},{\"accessor\":\"1987\",\"name\":\"1987\",\"type\":\"numeric\"},{\"accessor\":\"1992\",\"name\":\"1992\",\"type\":\"numeric\"},{\"accessor\":\"1997\",\"name\":\"1997\",\"type\":\"numeric\"},{\"accessor\":\"2002\",\"name\":\"2002\",\"type\":\"numeric\"},{\"accessor\":\"2007\",\"name\":\"2007\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"compact\":true,\"style\":{\"font-size\":\"12px\"},\"dataKey\":\"15f1fbb3237d2f33f6707a071decb70f\",\"key\":\"15f1fbb3237d2f33f6707a071decb70f\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nWhile we create the top-4 and others datasets separately, we will combine them later at the very last moment before writing them to the Excel template.\r\nNow that we have the datasets needed for 02_chart, let’s proceed to the create 02_table . This table gives you the count of countries that fall under various population ranges.\r\n02_table on Slide 2Let’s create 02_table. To create this table, we first create a new variable called pop_range.\r\n\r\n\r\npop_levels <- c('Less than 500K','500K - 1 Million',\r\n                '1M - 10 Million', '10M - 100 Million',\r\n                '100M - 1 Billion', 'More than 1 Billion')\r\n\r\ngp2007 <- gp %>% \r\n  filter(year == 2007) %>% \r\n  mutate(pop_range = case_when(pop < 5E5 ~ pop_levels[1],\r\n                               pop < 1E6 ~ pop_levels[2],\r\n                               pop < 1E7 ~ pop_levels[3],\r\n                               pop < 1E8 ~ pop_levels[4],\r\n                               pop < 1E9 ~ pop_levels[5],\r\n                               TRUE      ~ pop_levels[6]),\r\n         pop_range = factor(pop_range, levels = pop_levels))\r\n\r\npop_groups <- gp2007 %>% \r\n  group_by(region, pop_range, .drop = FALSE) %>% \r\n  summarise(`# of Countries` = n(),\r\n            .groups = 'drop') %>% \r\n  arrange(region, pop_range) %>% \r\n  rename(`Population Category` = pop_range)\r\n\r\nreactable(pop_groups, compact=TRUE, style = \"font-size:12px\")\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"region\":[\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\"],\"Population Category\":[\"Less than 500K\",\"500K - 1 Million\",\"1M - 10 Million\",\"10M - 100 Million\",\"100M - 1 Billion\",\"More than 1 Billion\",\"Less than 500K\",\"500K - 1 Million\",\"1M - 10 Million\",\"10M - 100 Million\",\"100M - 1 Billion\",\"More than 1 Billion\",\"Less than 500K\",\"500K - 1 Million\",\"1M - 10 Million\",\"10M - 100 Million\",\"100M - 1 Billion\",\"More than 1 Billion\",\"Less than 500K\",\"500K - 1 Million\",\"1M - 10 Million\",\"10M - 100 Million\",\"100M - 1 Billion\",\"More than 1 Billion\"],\"# of Countries\":[2,3,21,25,1,0,0,0,13,9,3,0,0,1,10,18,4,2,1,1,14,14,0,0]},\"columns\":[{\"accessor\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"accessor\":\"Population Category\",\"name\":\"Population Category\",\"type\":\"factor\"},{\"accessor\":\"# of Countries\",\"name\":\"# of Countries\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"compact\":true,\"style\":{\"font-size\":\"12px\"},\"dataKey\":\"c4f576614516dedb7a57c056b205acff\",\"key\":\"c4f576614516dedb7a57c056b205acff\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nSlide 3\r\nSlide 3 contains 2 strings and one chart. The data for the chart looks as shown below.\r\n03_chart table for Slide 3The data for 03_chart is the list of top 10 countries in each region as per latest record i.e. 2007. Let’s create the top10 table.\r\n\r\n\r\ntop10 <- gp %>% \r\n  filter(year == 2007) %>% \r\n  group_by(region) %>% \r\n  slice_max(pop, n = 10, with_ties = FALSE) %>% \r\n  ungroup() %>% \r\n  select(-year) %>% \r\n  mutate(pop = round(pop/1E6, 4)) %>% # population in millions\r\n  set_names(c(\"region\",\"country\",\"population\"))\r\n\r\nreactable(top10, compact=TRUE, style = \"font-size:12px\")\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"region\":[\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Africa\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Americas\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Asia-Pacific\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\",\"Europe\"],\"country\":[\"Nigeria\",\"Egypt\",\"Ethiopia\",\"Congo, Dem. Rep.\",\"South Africa\",\"Sudan\",\"Tanzania\",\"Kenya\",\"Morocco\",\"Algeria\",\"United States\",\"Brazil\",\"Mexico\",\"Colombia\",\"Argentina\",\"Canada\",\"Peru\",\"Venezuela\",\"Chile\",\"Ecuador\",\"China\",\"India\",\"Indonesia\",\"Pakistan\",\"Bangladesh\",\"Japan\",\"Philippines\",\"Vietnam\",\"Iran\",\"Thailand\",\"Germany\",\"Turkey\",\"France\",\"United Kingdom\",\"Italy\",\"Spain\",\"Poland\",\"Romania\",\"Netherlands\",\"Greece\"],\"population\":[135.0312,80.2645,76.5119,64.6068,43.9978,42.2929,38.1396,35.6102,33.7572,33.3332,301.1399,190.0106,108.7009,44.2276,40.3019,33.3901,28.6748,26.0847,16.2847,13.7557,1318.6831,1110.3963,223.547,169.2706,150.4483,127.468,91.0773,85.2624,69.4536,65.0681,82.401,71.1586,61.0839,60.7762,58.1477,40.4482,38.5182,22.2761,16.5706,10.7063]},\"columns\":[{\"accessor\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"accessor\":\"country\",\"name\":\"country\",\"type\":\"character\"},{\"accessor\":\"population\",\"name\":\"population\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"compact\":true,\"style\":{\"font-size\":\"12px\"},\"dataKey\":\"e021d757226dfc4c39c1d79e5a5b4803\",\"key\":\"e021d757226dfc4c39c1d79e5a5b4803\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nThe for loop!\r\nWe now have to load the Excel template with the data at appropriate cell locations for one region at a time. Since we have about 4 regions, we will create a vector of unique regions to iterate over.\r\n\r\n\r\nunique_regions <- gp %>% distinct(region) %>% pull()\r\ncat(unique_regions, sep = \"\\n\")\r\n\r\n\r\nAsia-Pacific\r\nEurope\r\nAfrica\r\nAmericas\r\n\r\nAs our last step, we will create the for loop that will iterate over unique_regions , filter the datasets for each region, write them to the Excel Template, save the template with temporary name. We save the file with different name to prevent unintentionally corrupting the Excel macro template. Finally, we run the macro in the renamed file.\r\nThe code will look something like this\r\n\r\n\r\nfor (region in unique_regions) {\r\n  \r\n  # Step 1: filter the data sets\r\n  # Step 2: write the data sets\r\n  # Step 3: save the excel template with different name\r\n  # Step 4: load the renamed Excel file\r\n  # Step 5: run macro\r\n}\r\n\r\n\r\n\r\nLet’s populate the above for loop with the code we need.\r\n\r\n\r\nfor (curr_region in unique_regions) {\r\n  \r\n  # Step 1: filter the data sets\r\n  \r\n  # Slide 1\r\n  S1_title <- paste(curr_region, \"Population\")\r\n  S1_subtitle <- paste(\"Vishal Katti\",\"|\",format(Sys.Date(),\"%b %d, %Y\"), sep = \"   \")\r\n  \r\n  # Slide 2\r\n  S2_title <- paste(curr_region, \"Population since 1952\")\r\n  \r\n  S2_top4 <- top4        %>% filter(region == all_of(curr_region)) %>% select(-region) %>% arrange(desc(`2007`))\r\n  S2_others <- others    %>% filter(region == all_of(curr_region)) %>% select(-region)\r\n  S2_top5 <- bind_rows(S2_top4, S2_others)\r\n  \r\n  S2_table <- pop_groups %>% filter(region == all_of(curr_region)) %>% select(-region)\r\n  \r\n  # Slide 3\r\n  S3_title <- paste(\"Top 10 most populated countries in\", curr_region)\r\n  \r\n  S3_chart <- top10      %>% filter(region == all_of(curr_region)) %>% select(-region)\r\n  \r\n  S3_factoid <- paste(\"The population of\", S3_chart$country[1], \"is approx.\",\r\n                      round(S3_chart$population[1]/S3_chart$population[10], 0),\r\n                      \"times that of\", S3_chart$country[10])\r\n  \r\n  # Step 2: write the data sets\r\n  \r\n  # Load the template\r\n  wb <- loadWorkbook(\"path/to/template/XL2PPT.xlsm\") # relative to this R script\r\n  sht <- \"Sheet1\"\r\n  \r\n  # write data to coordinate (col, row)\r\n  writeData(wb, sht, S1_title,    xy = c(3, 3),  colNames = FALSE)\r\n  writeData(wb, sht, S1_subtitle, xy = c(3, 4),  colNames = FALSE)\r\n  writeData(wb, sht, S2_title,    xy = c(3, 7),  colNames = FALSE)\r\n  writeData(wb, sht, S2_top5,     xy = c(3, 9),  colNames = TRUE)\r\n  writeData(wb, sht, S2_table,    xy = c(18, 9), colNames = TRUE)\r\n  writeData(wb, sht, S3_title,    xy = c(3, 18), colNames = FALSE)\r\n  writeData(wb, sht, S3_factoid,  xy = c(3, 19), colNames = FALSE)\r\n  writeData(wb, sht, S3_chart,    xy = c(3, 21), colNames = TRUE)\r\n  \r\n  # Step 3: save the excel template with different name\r\n  saveWorkbook(wb, \"path/to/template/XL2PPT_edited.xlsm\", overwrite = TRUE)\r\n  gc(verbose = TRUE)\r\n  Sys.sleep(2)\r\n  \r\n  # Step 4: load the renamed Excel file\r\n  # Create Excel Application\r\n  xlApp <- COMCreate(\"Excel.Application\")\r\n\r\n  # Open the Macro Excel book\r\n  xlWbk <- xlApp$Workbooks()$Open(normalizePath(\"path/to/template/XL2PPT_edited.xlsm\", winslash = \"/\")) # Change to your directory\r\n  # its ok to run macro without visible excel application\r\n  # If you want to see your workbook, please set it to TRUE\r\n  xlApp[[\"Visible\"]] <- FALSE\r\n  \r\n  # Step 5: run macro\r\n  xlApp$Run(\"Create_Continental_Deck\") # Name of Macro to run\r\n\r\n  xlWbk$Close(TRUE) # save and close excel book\r\n  xlApp$Quit()\r\n  gc(verbose = TRUE)\r\n  Sys.sleep(2)\r\n}\r\n\r\n\r\n\r\nOnce the code runs completely, you will see 4 new PowerPoint Presentations in your working folder.\r\nOutput FilesYou can download the full R script from here.\r\nReferences & Citations\r\nJennifer Bryan (2017). gapminder: Data from Gapminder. R package version 0.3.0.\r\nhttps://CRAN.R-project.org/package=gapminder\r\nHadley Wickham, Romain François, Lionel Henry and Kirill Müller (2021). dplyr: A Grammar of Data Manipulation. R package version 1.0.7. https://CRAN.R-project.org/package=dplyr\r\nHadley Wickham (2021). tidyr: Tidy Messy Data. R package version 1.1.3.\r\nhttps://CRAN.R-project.org/package=tidyr\r\nGreg Lin (2020). reactable: Interactive Data Tables Based on ‘React Table’. R\r\npackage version 0.2.3. https://CRAN.R-project.org/package=reactable\r\nPhilipp Schauberger and Alexander Walker (2021). openxlsx: Read, Write and Edit xlsx\r\nFiles. R package version 4.2.4. https://CRAN.R-project.org/package=openxlsx\r\nDuncan Temple Lang (NA). RDCOMClient: R-DCOM client. http://www.omegahat.net/RDCOMClient, http://www.omegahat.net http://www.omegahat.net/bugs.\r\nhttps://docs.microsoft.com/en-us/office/vba/api/overview/excel\r\nhttps://docs.microsoft.com/en-us/office/vba/api/overview/powerpoint\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-12-29-rtovbatoppt/images/R2XL2PPT_logo.png",
    "last_modified": "2021-12-29T20:32:29+05:30",
    "input_file": {},
    "preview_width": 1500,
    "preview_height": 619
  },
  {
    "path": "posts/2021-08-29-rtovbatoppt/",
    "title": "Unholy Trinity of R, Excel VBA and Powerpoint - Part 1 of 2",
    "description": "Using R to trigger Excel VBA macros to create PowerPoint presentations!",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2021-10-19",
    "categories": [
      "Rstats",
      "Excel",
      "VBA",
      "PowerPoint"
    ],
    "contents": "\r\n\r\nContents\r\nTL;DR\r\nThe PowerPoint Template\r\nThe Excel Template\r\nThe VBA Macro\r\nR\r\n\r\nOne of the most common tasks in most offices, is creating presentations and reports in Microsoft PowerPoint. While the tool is great for creating ad hoc presentations, editing the same with new data on a periodic basis gets tedious. Now, I know that some wonderful packages like officer and officedown exist that enable us to create PowerPoint presentations with editable charts from R itself. You can read all about this in the amazing Alison Hill’s blog post “Up and running with officedown”.\r\nSince I discovered R while looking for a better alternative to VBA for data analysis and Excel/PowerPoint automation, the following is an alternative workflow to create multiple PowerPoint presentations using a combination of these technologies. Note that this workflow uses the RDCOMClient package which works in Windows environment only.\r\nTL;DR\r\nIn this 2-part blog, we create a PowerPoint template with named placeholders which we populate from an Excel file using VBA. The Excel file is loaded with data using R with the help of openxlsx package and then the macro is triggered using the RDCOMClient package.\r\nThis solution has great potential to give you the same feeling as those Jurassic Park scientists that Dr. Ian Malcolm remarked about!\r\nAdvantages of this approach over officer and officedown:\r\nSlide/content/header/footer formatting control is in the PowerPoint template rather than R code.\r\nAll charts are native and can contain any feature (dual axis, mixed data series like bar + line, line + points). All Excel chart-types are available. Go wild!\r\nYou can use any PowerPoint template design (Yes, even your sad/weird/exciting corporate template!).\r\nLet’s begin.\r\nSuppose we want to automate the following PowerPoint presentation. It contains 3 slides with a title slide and 2 content slides having graphs and tables created from the gapminder dataset. This .pptx file also has a custom footer.\r\nThe Gapminder World Population ReportWe want to create the same presentation with same structure but at a continent-level. gapminder has data for 5 continents and we wish to create 5 presentations by the end of this.\r\nThe PowerPoint Template\r\nIn this approach, we start with the PowerPoint presentation file. We will create a template with placeholders and charts with dummy data. Usually, you would have a copy of the .pptx file you want to automate. Save a copy of it as a PowerPoint Template (.potx), ideally to your R Project folder. To know more about what an R Project is, read about it here. In my case, I’ve created a new R Project folder named R2XL2PPT as shown below.\r\nSave As PowerPoint Template (.potx)Now let us prep the template. If you open the template file by double-click or right-click > New, it would open a fresh .pptx presentation using the template. Right-Click and click Open in the context menu to open the .potx template file for editing.\r\nCORRECT: Right-Click > OpenOnce you have the template open, we will add names to all the text placeholders, tables and graphs we wish to update. To update the placeholder name:\r\nSelect the shape/text-area/table/graph.\r\nFrom Shape Format, click Selection Pane.\r\nIn the Selection Pane, change the name of the selected item.\r\nAdd shape names from Selection PaneAdvisory: We use the format NN_[Position]Object where NN is the slide number, [Position] is the either TopLeft, TopRight, BottomLeft, BottomRight or any other position and finally, Object is either Table, Chart, Title, Subtitle, TextBox etc. You can use any fancy identifier here, just make sure that your future self and others can recognise them easily.\r\nOnce you set the names of all the items that you want to customise, save the template.\r\nDownload the GP_template.potx template here.\r\nThe Excel Template\r\nTo populate all the named items in the PowerPoint template, we will now create an Excel document which looks identical to the template with respect to the named items. Please see image below.\r\nPowerPoint item to Excel named range mappingFor every named item, depending on whether it is a textbox or chart or table, we will create a named range for that item. For example, for item 01_title in the PowerPoint template, we create a S1_title named range (which points to cell C3) as a placeholder for it. If you don’t know how to create a named range in Excel, read more here.\r\n\r\nExcel does not allow named ranges names to start with a number, hence 01_title is mapped to S1_title. The S stands for Slide. Just one of those Excel quirks I guess!\r\n\r\nYou can set a single Excel cell as named range for each textbox in the PowerPoint template. You can copy-paste tables from Powerpoint to the Excel template directly. The entire table must be set as a named range.\r\nFor charts, right-click the chart in PowerPoint and select Edit Data. An excel worksheet is displayed with the underlying data. Copy-paste the entire data into the Excel template.\r\nExcel Chart: Right Click > Edit DataFor the GP_template.potx, the corresponding excel template XL2PPT.xlsm looks like the below image. Please note that this template does not have the VBA macro yet.\r\nXL2PPT designThe VBA Macro\r\nWe want the VBA macro to:\r\nOpen a new instance of PowerPoint presentation using the GP_template.potx file.\r\nCopy text/numbers from various placeholders and replace existing text/numbers in the PowerPoint presentation.\r\nSave the presentation with custom file name with .pptx extension.\r\nThe actual mapping of the named ranges in the Excel template to the named shapes in the PowerPoint template happens in the VBA code. However, at this stage, you can actually create the PowerPoint presentation by copying the numbers into the Excel template and hitting the big RUN MACRO button.\r\nFor your reference, I am embedding the VBA macro code below. You can download the XL2PPT.xlsm file from here.\r\n\r\n VBA Macro Code \r\n\r\n\r\nR\r\nSuppose we want to create a 10 variations of PowerPoint presentation using the same template. While creating the presentation from Excel is now automated, how about creating the numbers for each of those 10 variations? This is where we bring in R with the openxlsx and RDCOMClient packages. We use the tidyverse set of packages to read in data, clean and massage the data into the various formats we need, openxlsx to write the data (single numbers, text or tables of numbers) to the Excel template and RDCOMClient to run the embedded VBA code in the Excel template.\r\nCheck out the upcoming Part 2 of this blog to see how to run VBA code using R. Let me know if you find this useful or any corrections required in the comments below.\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-08-29-rtovbatoppt/images/R2XL2PPT_logo.png",
    "last_modified": "2021-10-25T07:47:43+05:30",
    "input_file": {},
    "preview_width": 1500,
    "preview_height": 619
  },
  {
    "path": "posts/2021-07-27-drilldown/",
    "title": "Interactive Drill-down Tables using {reactable}",
    "description": "How to create multi-level tables with hidden rows",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2021-07-27",
    "categories": [
      "Rstats",
      "reactable",
      "drill-down"
    ],
    "contents": "\r\n\r\nContents\r\nTop-Level data:\r\ncourse\r\nSecond Level Data:\r\nstudent\r\nVanilla reactable\r\nBasic Formatting\r\nGrouping and\r\nAggregating\r\nThe final Drill-down\r\nTable\r\nConclusion\r\nReferences & Citations\r\n\r\nWe often come across denormalized data that has 2 or more levels of\r\ninformation. For example, top-level info like course info with data\r\nfields like course id, course name, description, start/end date and\r\nsecond-level info like student info with data fields like with student\r\nid, student name, age and gender. We may also have these two groups of\r\ndata as separate tables with a primary-key foreign-key design, usually\r\nfrom a well-designed SQL database.\r\nLet us create some data.\r\nTop-Level data:\r\ncourse\r\n\r\n\r\nlibrary(dplyr, quietly = TRUE, warn.conflicts = FALSE)\r\nlibrary(rmarkdown, quietly = TRUE, warn.conflicts = FALSE)\r\n\r\ncourse <- tibble(course_id           = 1:4,\r\n                 course_name         = paste(\"Course\", LETTERS[1:4]),\r\n                 start_date          = seq.Date(from = lubridate::as_date(\"2021-01-01\"), by = \"month\", length.out = 4),\r\n                 end_date            = lubridate::ceiling_date(start_date, unit = \"month\") - 1)\r\n\r\npaged_table(course)\r\n\r\n\r\n\r\n\r\n{\"columns\":[{\"label\":[\"course_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"course_name\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[4],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Course A\",\"3\":\"2021-01-01\",\"4\":\"2021-01-31\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\"},{\"1\":\"4\",\"2\":\"Course D\",\"3\":\"2021-04-01\",\"4\":\"2021-04-30\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\r\n  \r\n\r\nSecond Level Data:\r\nstudent\r\n\r\n\r\nset.seed(42)\r\nstudent <- tibble(s_id      = 1:20,\r\n                  s_name    = paste(\"Student\", LETTERS[1:20]),\r\n                  gender    = sample(c(\"X\",\"Y\",\"Z\"), 20, replace = TRUE),\r\n                  age       = sample(18:35, 20, replace = TRUE),\r\n                  course_id = sample(1:4, 20, replace = TRUE))\r\n\r\npaged_table(student)\r\n\r\n\r\n\r\n\r\n{\"columns\":[{\"label\":[\"s_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"s_name\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"gender\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"age\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"course_id\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Student A\",\"3\":\"X\",\"4\":\"21\",\"5\":\"3\"},{\"1\":\"2\",\"2\":\"Student B\",\"3\":\"X\",\"4\":\"22\",\"5\":\"4\"},{\"1\":\"3\",\"2\":\"Student C\",\"3\":\"X\",\"4\":\"30\",\"5\":\"3\"},{\"1\":\"4\",\"2\":\"Student D\",\"3\":\"X\",\"4\":\"22\",\"5\":\"1\"},{\"1\":\"5\",\"2\":\"Student E\",\"3\":\"Y\",\"4\":\"19\",\"5\":\"1\"},{\"1\":\"6\",\"2\":\"Student F\",\"3\":\"Y\",\"4\":\"25\",\"5\":\"2\"},{\"1\":\"7\",\"2\":\"Student G\",\"3\":\"Y\",\"4\":\"20\",\"5\":\"2\"},{\"1\":\"8\",\"2\":\"Student H\",\"3\":\"X\",\"4\":\"18\",\"5\":\"2\"},{\"1\":\"9\",\"2\":\"Student I\",\"3\":\"Z\",\"4\":\"27\",\"5\":\"2\"},{\"1\":\"10\",\"2\":\"Student J\",\"3\":\"Z\",\"4\":\"28\",\"5\":\"2\"},{\"1\":\"11\",\"2\":\"Student K\",\"3\":\"X\",\"4\":\"32\",\"5\":\"4\"},{\"1\":\"12\",\"2\":\"Student L\",\"3\":\"X\",\"4\":\"25\",\"5\":\"3\"},{\"1\":\"13\",\"2\":\"Student M\",\"3\":\"Y\",\"4\":\"21\",\"5\":\"2\"},{\"1\":\"14\",\"2\":\"Student N\",\"3\":\"Y\",\"4\":\"21\",\"5\":\"1\"},{\"1\":\"15\",\"2\":\"Student O\",\"3\":\"Y\",\"4\":\"35\",\"5\":\"2\"},{\"1\":\"16\",\"2\":\"Student P\",\"3\":\"Z\",\"4\":\"30\",\"5\":\"3\"},{\"1\":\"17\",\"2\":\"Student Q\",\"3\":\"Z\",\"4\":\"22\",\"5\":\"2\"},{\"1\":\"18\",\"2\":\"Student R\",\"3\":\"X\",\"4\":\"21\",\"5\":\"2\"},{\"1\":\"19\",\"2\":\"Student S\",\"3\":\"X\",\"4\":\"19\",\"5\":\"2\"},{\"1\":\"20\",\"2\":\"Student T\",\"3\":\"Z\",\"4\":\"35\",\"5\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\r\n  \r\n\r\nIf we are sourcing data from a database, it is probable that you\r\nwould see these 2 levels of data in 2 separate tables/views, but most\r\nbusiness users are comfortable with MS Excel and want all the\r\ndata in one sheet!!\r\nSo the data actually looks something like this.\r\n\r\n\r\ncombined_df <- left_join(course, student, by = \"course_id\")\r\n\r\npaged_table(combined_df)\r\n\r\n\r\n\r\n\r\n{\"columns\":[{\"label\":[\"course_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"course_name\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[4],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"s_id\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"s_name\"],\"name\":[6],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"gender\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"age\"],\"name\":[8],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Course A\",\"3\":\"2021-01-01\",\"4\":\"2021-01-31\",\"5\":\"4\",\"6\":\"Student D\",\"7\":\"X\",\"8\":\"22\"},{\"1\":\"1\",\"2\":\"Course A\",\"3\":\"2021-01-01\",\"4\":\"2021-01-31\",\"5\":\"5\",\"6\":\"Student E\",\"7\":\"Y\",\"8\":\"19\"},{\"1\":\"1\",\"2\":\"Course A\",\"3\":\"2021-01-01\",\"4\":\"2021-01-31\",\"5\":\"14\",\"6\":\"Student N\",\"7\":\"Y\",\"8\":\"21\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"6\",\"6\":\"Student F\",\"7\":\"Y\",\"8\":\"25\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"7\",\"6\":\"Student G\",\"7\":\"Y\",\"8\":\"20\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"8\",\"6\":\"Student H\",\"7\":\"X\",\"8\":\"18\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"9\",\"6\":\"Student I\",\"7\":\"Z\",\"8\":\"27\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"10\",\"6\":\"Student J\",\"7\":\"Z\",\"8\":\"28\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"13\",\"6\":\"Student M\",\"7\":\"Y\",\"8\":\"21\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"15\",\"6\":\"Student O\",\"7\":\"Y\",\"8\":\"35\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"17\",\"6\":\"Student Q\",\"7\":\"Z\",\"8\":\"22\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"18\",\"6\":\"Student R\",\"7\":\"X\",\"8\":\"21\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"19\",\"6\":\"Student S\",\"7\":\"X\",\"8\":\"19\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\",\"5\":\"1\",\"6\":\"Student A\",\"7\":\"X\",\"8\":\"21\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\",\"5\":\"3\",\"6\":\"Student C\",\"7\":\"X\",\"8\":\"30\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\",\"5\":\"12\",\"6\":\"Student L\",\"7\":\"X\",\"8\":\"25\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\",\"5\":\"16\",\"6\":\"Student P\",\"7\":\"Z\",\"8\":\"30\"},{\"1\":\"4\",\"2\":\"Course D\",\"3\":\"2021-04-01\",\"4\":\"2021-04-30\",\"5\":\"2\",\"6\":\"Student B\",\"7\":\"X\",\"8\":\"22\"},{\"1\":\"4\",\"2\":\"Course D\",\"3\":\"2021-04-01\",\"4\":\"2021-04-30\",\"5\":\"11\",\"6\":\"Student K\",\"7\":\"X\",\"8\":\"32\"},{\"1\":\"4\",\"2\":\"Course D\",\"3\":\"2021-04-01\",\"4\":\"2021-04-30\",\"5\":\"20\",\"6\":\"Student T\",\"7\":\"Z\",\"8\":\"35\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\r\n  \r\n\r\nDisplaying such data in a table causes all the top-level data fields\r\nto repeat for every second-level record. You can see that\r\ncourse_id, course_name,\r\nstart_date and end_date columns repeat for all\r\nstudents who enrolled in the same course. Take a moment to think about\r\nhow would you display such data in an interactive table in a web page,\r\nHTML report or Shiny app.\r\nIt is advisable to split such denormalized data into normalized data\r\ni.e. create the original top-level and second level tables from the\r\ncombined_df.\r\nVanilla reactable\r\nOne of my favorite R packages is {reactable}. The\r\ndefault output creates a neat interactive table with pagination (if data\r\nhas more than 10 rows) and ability to sort columns.\r\n\r\n\r\nlibrary(reactable, quietly = TRUE, warn.conflicts = FALSE)\r\n\r\nreactable(data = combined_df)\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],\"course_name\":[\"Course A\",\"Course A\",\"Course A\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course C\",\"Course C\",\"Course C\",\"Course C\",\"Course D\",\"Course D\",\"Course D\"],\"start_date\":[\"2021-01-01\",\"2021-01-01\",\"2021-01-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-04-01\",\"2021-04-01\",\"2021-04-01\"],\"end_date\":[\"2021-01-31\",\"2021-01-31\",\"2021-01-31\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-04-30\",\"2021-04-30\",\"2021-04-30\"],\"s_id\":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],\"s_name\":[\"Student D\",\"Student E\",\"Student N\",\"Student F\",\"Student G\",\"Student H\",\"Student I\",\"Student J\",\"Student M\",\"Student O\",\"Student Q\",\"Student R\",\"Student S\",\"Student A\",\"Student C\",\"Student L\",\"Student P\",\"Student B\",\"Student K\",\"Student T\"],\"gender\":[\"X\",\"Y\",\"Y\",\"Y\",\"Y\",\"X\",\"Z\",\"Z\",\"Y\",\"Y\",\"Z\",\"X\",\"X\",\"X\",\"X\",\"X\",\"Z\",\"X\",\"X\",\"Z\"],\"age\":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"course_id\",\"type\":\"numeric\"},{\"accessor\":\"course_name\",\"name\":\"course_name\",\"type\":\"character\"},{\"accessor\":\"start_date\",\"name\":\"start_date\",\"type\":\"Date\"},{\"accessor\":\"end_date\",\"name\":\"end_date\",\"type\":\"Date\"},{\"accessor\":\"s_id\",\"name\":\"s_id\",\"type\":\"numeric\"},{\"accessor\":\"s_name\",\"name\":\"s_name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"gender\",\"type\":\"character\"},{\"accessor\":\"age\",\"name\":\"age\",\"type\":\"numeric\"}],\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"dataKey\":\"413c1f3c101a174f7070712d78c69feb\",\"key\":\"413c1f3c101a174f7070712d78c69feb\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nBasic Formatting\r\nWith some additional tweaks, we can make it look better.\r\n\r\n\r\nreactable(\r\n  data       = combined_df,\r\n  compact    = TRUE, # for minimum row height\r\n  filterable = TRUE, # for individual column filters\r\n  striped    = TRUE, # banded rows\r\n  resizable  = TRUE, # for resizable column widths\r\n  columns    = list( # define custom header name, width, alignment etc.\r\n    course_id   = colDef(name = \"CID\",         width = 50,  align = \"center\"),\r\n    course_name = colDef(name = \"Course Name\", width = 140),\r\n    start_date  = colDef(name = \"Start Date\",  width = 120, align = \"center\"),\r\n    end_date    = colDef(name = \"End Date\",    width = 120, align = \"center\"),\r\n    s_id        = colDef(name = \"SID\",         width = 70,  align = \"center\"),\r\n    s_name      = colDef(name = \"Student Name\"),\r\n    gender      = colDef(name = \"Gender\",      width = 80,  align = \"center\"),\r\n    age         = colDef(name = \"Age\",         width = 50)\r\n  )\r\n)\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],\"course_name\":[\"Course A\",\"Course A\",\"Course A\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course C\",\"Course C\",\"Course C\",\"Course C\",\"Course D\",\"Course D\",\"Course D\"],\"start_date\":[\"2021-01-01\",\"2021-01-01\",\"2021-01-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-04-01\",\"2021-04-01\",\"2021-04-01\"],\"end_date\":[\"2021-01-31\",\"2021-01-31\",\"2021-01-31\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-04-30\",\"2021-04-30\",\"2021-04-30\"],\"s_id\":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],\"s_name\":[\"Student D\",\"Student E\",\"Student N\",\"Student F\",\"Student G\",\"Student H\",\"Student I\",\"Student J\",\"Student M\",\"Student O\",\"Student Q\",\"Student R\",\"Student S\",\"Student A\",\"Student C\",\"Student L\",\"Student P\",\"Student B\",\"Student K\",\"Student T\"],\"gender\":[\"X\",\"Y\",\"Y\",\"Y\",\"Y\",\"X\",\"Z\",\"Z\",\"Y\",\"Y\",\"Z\",\"X\",\"X\",\"X\",\"X\",\"X\",\"Z\",\"X\",\"X\",\"Z\"],\"age\":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"CID\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"},{\"accessor\":\"course_name\",\"name\":\"Course Name\",\"type\":\"character\",\"width\":140},{\"accessor\":\"start_date\",\"name\":\"Start Date\",\"type\":\"Date\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"end_date\",\"name\":\"End Date\",\"type\":\"Date\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":80,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"striped\":true,\"compact\":true,\"dataKey\":\"37ac57f783425a81c3f289334adfb3a2\",\"key\":\"37ac57f783425a81c3f289334adfb3a2\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nHowever, the problem of repeating top-level fields still\r\npersists.\r\nGrouping and Aggregating\r\n{reactable} has a groupBy argument\r\nwhich lets us combined rows with common data fields and the\r\naggregate argument inside colDef lets us\r\ndefine what aggregation to be used for each column of the top-level\r\ndata.\r\n\r\n\r\nreactable(\r\n  data       = combined_df,\r\n  compact    = TRUE, # for minimum row height\r\n  filterable = TRUE, # for individual column filters\r\n  striped    = TRUE, # banded rows\r\n  resizable  = TRUE, # for resizable column widths\r\n  groupBy    = \"course_id\",\r\n  columns    = list(\r\n    # show count of students in each course\r\n    course_id   = colDef(name = \"CID\",         width = 100,  align = \"left\",    aggregate = \"count\"),  \r\n    # show unique course name\r\n    course_name = colDef(name = \"Course Name\", width = 140,                     aggregate = \"unique\"), \r\n    # show unique start date\r\n    start_date  = colDef(name = \"Start Date\",  width = 120,  align = \"center\",  aggregate = \"unique\"), \r\n    # show unique end date\r\n    end_date    = colDef(name = \"End Date\",    width = 120,  align = \"center\",  aggregate = \"unique\"), \r\n    s_id        = colDef(name = \"SID\",         width = 70,   align = \"center\"),\r\n    s_name      = colDef(name = \"Student Name\"),\r\n    gender      = colDef(name = \"Gender\",      width = 80,   align = \"center\"),\r\n    age         = colDef(name = \"Age\",         width = 50)\r\n  )\r\n)\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],\"course_name\":[\"Course A\",\"Course A\",\"Course A\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course C\",\"Course C\",\"Course C\",\"Course C\",\"Course D\",\"Course D\",\"Course D\"],\"start_date\":[\"2021-01-01\",\"2021-01-01\",\"2021-01-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-04-01\",\"2021-04-01\",\"2021-04-01\"],\"end_date\":[\"2021-01-31\",\"2021-01-31\",\"2021-01-31\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-04-30\",\"2021-04-30\",\"2021-04-30\"],\"s_id\":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],\"s_name\":[\"Student D\",\"Student E\",\"Student N\",\"Student F\",\"Student G\",\"Student H\",\"Student I\",\"Student J\",\"Student M\",\"Student O\",\"Student Q\",\"Student R\",\"Student S\",\"Student A\",\"Student C\",\"Student L\",\"Student P\",\"Student B\",\"Student K\",\"Student T\"],\"gender\":[\"X\",\"Y\",\"Y\",\"Y\",\"Y\",\"X\",\"Z\",\"Z\",\"Y\",\"Y\",\"Z\",\"X\",\"X\",\"X\",\"X\",\"X\",\"Z\",\"X\",\"X\",\"Z\"],\"age\":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"CID\",\"type\":\"numeric\",\"aggregate\":\"count\",\"width\":100,\"align\":\"left\"},{\"accessor\":\"course_name\",\"name\":\"Course Name\",\"type\":\"character\",\"aggregate\":\"unique\",\"width\":140},{\"accessor\":\"start_date\",\"name\":\"Start Date\",\"type\":\"Date\",\"aggregate\":\"unique\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"end_date\",\"name\":\"End Date\",\"type\":\"Date\",\"aggregate\":\"unique\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":80,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50}],\"pivotBy\":[\"course_id\"],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"striped\":true,\"compact\":true,\"dataKey\":\"e9fc15f3a53a06ad3569f7b3f70a31cd\",\"key\":\"e9fc15f3a53a06ad3569f7b3f70a31cd\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nIn this case, all the columns which are not aggregated\r\nremain hidden. Clicking the little triangle in the CID\r\ncolumn displays the hidden rows. Looks better, but again, the issue of\r\nduplicated data remains.\r\nYou can aggregate the second-level columns too, but this distorts the\r\ntable and frankly, looks ugly. Here I aggregate the SID\r\ncolumn in addition to all the other top-level columns.\r\n\r\n\r\nreactable(\r\n  data       = combined_df,\r\n  compact    = TRUE, # for minimum row height\r\n  filterable = TRUE, # for individual column filters\r\n  striped    = TRUE, # banded rows\r\n  resizable  = TRUE, # for resizable column widths\r\n  groupBy    = \"course_id\",\r\n  columns    = list(\r\n    course_id   = colDef(name = \"CID\",         width = 100,  align = \"left\",    aggregate = \"count\"),\r\n    course_name = colDef(name = \"Course Name\", width = 140,                     aggregate = \"unique\"),\r\n    start_date  = colDef(name = \"Start Date\",  width = 120,  align = \"center\",  aggregate = \"unique\"),\r\n    end_date    = colDef(name = \"End Date\",    width = 120,  align = \"center\",  aggregate = \"unique\"),\r\n    # YIKES!! Aggregating Student ID to show unique ids in each course.\r\n    s_id        = colDef(name = \"SID\",         width = 70,   align = \"center\",  aggregate = \"unique\"), \r\n    s_name      = colDef(name = \"Student Name\"),\r\n    gender      = colDef(name = \"Gender\",      width = 80,   align = \"center\"),\r\n    age         = colDef(name = \"Age\",         width = 50)\r\n  )\r\n)\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],\"course_name\":[\"Course A\",\"Course A\",\"Course A\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course B\",\"Course C\",\"Course C\",\"Course C\",\"Course C\",\"Course D\",\"Course D\",\"Course D\"],\"start_date\":[\"2021-01-01\",\"2021-01-01\",\"2021-01-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-02-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-03-01\",\"2021-04-01\",\"2021-04-01\",\"2021-04-01\"],\"end_date\":[\"2021-01-31\",\"2021-01-31\",\"2021-01-31\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-02-28\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-03-31\",\"2021-04-30\",\"2021-04-30\",\"2021-04-30\"],\"s_id\":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],\"s_name\":[\"Student D\",\"Student E\",\"Student N\",\"Student F\",\"Student G\",\"Student H\",\"Student I\",\"Student J\",\"Student M\",\"Student O\",\"Student Q\",\"Student R\",\"Student S\",\"Student A\",\"Student C\",\"Student L\",\"Student P\",\"Student B\",\"Student K\",\"Student T\"],\"gender\":[\"X\",\"Y\",\"Y\",\"Y\",\"Y\",\"X\",\"Z\",\"Z\",\"Y\",\"Y\",\"Z\",\"X\",\"X\",\"X\",\"X\",\"X\",\"Z\",\"X\",\"X\",\"Z\"],\"age\":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"CID\",\"type\":\"numeric\",\"aggregate\":\"count\",\"width\":100,\"align\":\"left\"},{\"accessor\":\"course_name\",\"name\":\"Course Name\",\"type\":\"character\",\"aggregate\":\"unique\",\"width\":140},{\"accessor\":\"start_date\",\"name\":\"Start Date\",\"type\":\"Date\",\"aggregate\":\"unique\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"end_date\",\"name\":\"End Date\",\"type\":\"Date\",\"aggregate\":\"unique\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"aggregate\":\"unique\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":80,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50}],\"pivotBy\":[\"course_id\"],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"striped\":true,\"compact\":true,\"dataKey\":\"51a6dfecd993aea3dbb11e027155fa81\",\"key\":\"51a6dfecd993aea3dbb11e027155fa81\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nWouldn’t it be nice if we could display only the top-level columns by\r\ndefault and on clicking the small triangle for a row, show all the\r\nsecond-level columns corresponding to that row only, like a drill-down\r\ntable?\r\nTo do this we need 2 separate tables. Earlier in this post, I said it\r\nis advisable to split such denormalized data into normalized data\r\ni.e. create the original top-level and second level tables from the\r\ncombined_df. Let’s recreate the 2 tables.\r\nI want to demonstrate how we go from the combined data to the 2\r\ntables. Hence I will not use the course and\r\nstudent tables created earlier.\r\nCreating the top_level table using just the columns in\r\ncourse. Let’s also create a new column\r\nn_students depicting count of students in each course.\r\n\r\n\r\ntop_level <- combined_df %>% \r\n  # Only course info columns\r\n  count(course_id, course_name, start_date, end_date, name = \"n_students\") \r\n\r\npaged_table(top_level)\r\n\r\n\r\n\r\n\r\n{\"columns\":[{\"label\":[\"course_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"course_name\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[4],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"n_students\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Course A\",\"3\":\"2021-01-01\",\"4\":\"2021-01-31\",\"5\":\"3\"},{\"1\":\"2\",\"2\":\"Course B\",\"3\":\"2021-02-01\",\"4\":\"2021-02-28\",\"5\":\"10\"},{\"1\":\"3\",\"2\":\"Course C\",\"3\":\"2021-03-01\",\"4\":\"2021-03-31\",\"5\":\"4\"},{\"1\":\"4\",\"2\":\"Course D\",\"3\":\"2021-04-01\",\"4\":\"2021-04-30\",\"5\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\r\n  \r\n\r\n\r\n\r\nsecond_level <- combined_df %>% \r\n  # Only Student info columns with unique identifier for Course\r\n  select(course_id, s_id, s_name, gender, age) %>% \r\n  arrange(s_id)\r\n\r\npaged_table(second_level)\r\n\r\n\r\n\r\n\r\n{\"columns\":[{\"label\":[\"course_id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"s_id\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"s_name\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"gender\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"age\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"3\",\"2\":\"1\",\"3\":\"Student A\",\"4\":\"X\",\"5\":\"21\"},{\"1\":\"4\",\"2\":\"2\",\"3\":\"Student B\",\"4\":\"X\",\"5\":\"22\"},{\"1\":\"3\",\"2\":\"3\",\"3\":\"Student C\",\"4\":\"X\",\"5\":\"30\"},{\"1\":\"1\",\"2\":\"4\",\"3\":\"Student D\",\"4\":\"X\",\"5\":\"22\"},{\"1\":\"1\",\"2\":\"5\",\"3\":\"Student E\",\"4\":\"Y\",\"5\":\"19\"},{\"1\":\"2\",\"2\":\"6\",\"3\":\"Student F\",\"4\":\"Y\",\"5\":\"25\"},{\"1\":\"2\",\"2\":\"7\",\"3\":\"Student G\",\"4\":\"Y\",\"5\":\"20\"},{\"1\":\"2\",\"2\":\"8\",\"3\":\"Student H\",\"4\":\"X\",\"5\":\"18\"},{\"1\":\"2\",\"2\":\"9\",\"3\":\"Student I\",\"4\":\"Z\",\"5\":\"27\"},{\"1\":\"2\",\"2\":\"10\",\"3\":\"Student J\",\"4\":\"Z\",\"5\":\"28\"},{\"1\":\"4\",\"2\":\"11\",\"3\":\"Student K\",\"4\":\"X\",\"5\":\"32\"},{\"1\":\"3\",\"2\":\"12\",\"3\":\"Student L\",\"4\":\"X\",\"5\":\"25\"},{\"1\":\"2\",\"2\":\"13\",\"3\":\"Student M\",\"4\":\"Y\",\"5\":\"21\"},{\"1\":\"1\",\"2\":\"14\",\"3\":\"Student N\",\"4\":\"Y\",\"5\":\"21\"},{\"1\":\"2\",\"2\":\"15\",\"3\":\"Student O\",\"4\":\"Y\",\"5\":\"35\"},{\"1\":\"3\",\"2\":\"16\",\"3\":\"Student P\",\"4\":\"Z\",\"5\":\"30\"},{\"1\":\"2\",\"2\":\"17\",\"3\":\"Student Q\",\"4\":\"Z\",\"5\":\"22\"},{\"1\":\"2\",\"2\":\"18\",\"3\":\"Student R\",\"4\":\"X\",\"5\":\"21\"},{\"1\":\"2\",\"2\":\"19\",\"3\":\"Student S\",\"4\":\"X\",\"5\":\"19\"},{\"1\":\"4\",\"2\":\"20\",\"3\":\"Student T\",\"4\":\"Z\",\"5\":\"35\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\r\n  \r\n\r\nThe final Drill-down Table\r\nNow that we have the 2 tables ready, let us now create the final\r\n{reactable}. The trick here is to use the\r\ndetails argument to which we pass another\r\n{reactable} of just the rows with students data\r\ncorresponding to given course.\r\n\r\n\r\nreactable(\r\n  data       = top_level,\r\n  compact    = TRUE, # for minimum row height\r\n  filterable = TRUE, # for individual column filters\r\n  striped    = TRUE, # banded rows\r\n  resizable  = TRUE, # for resizable column widths\r\n  columns    = list(\r\n    course_id   = colDef(name = \"CID\",             width = 50,  align = \"center\"),\r\n    course_name = colDef(name = \"Course Name\"), \r\n    start_date  = colDef(name = \"Start Date\",      width = 120, align = \"center\"),\r\n    end_date    = colDef(name = \"End Date\",        width = 120, align = \"center\"),\r\n    n_students  = colDef(name = \"No. of Students\", width = 130, align = \"center\")\r\n  ),\r\n  details = function(index) { # index is the row number of current row.\r\n    # sub-table of only those students for current row.\r\n    sec_lvl = second_level[second_level$course_id == top_level$course_id[index], ] \r\n    reactable(data       = sec_lvl,\r\n              compact    = TRUE, \r\n              filterable = TRUE,\r\n              bordered   = TRUE, \r\n              resizable  = TRUE,\r\n              columns    = list(\r\n                course_id   = colDef(show = FALSE), # hide the course id column\r\n                s_id        = colDef(name = \"SID\",    width = 70, align = \"center\"),\r\n                s_name      = colDef(name = \"Student Name\"),\r\n                gender      = colDef(name = \"Gender\", width = 90, align = \"center\"),\r\n                age         = colDef(name = \"Age\",    width = 50, align = \"center\")\r\n              )\r\n              )\r\n  }\r\n)\r\n\r\n\r\n\r\n{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,2,3,4],\"course_name\":[\"Course A\",\"Course B\",\"Course C\",\"Course D\"],\"start_date\":[\"2021-01-01\",\"2021-02-01\",\"2021-03-01\",\"2021-04-01\"],\"end_date\":[\"2021-01-31\",\"2021-02-28\",\"2021-03-31\",\"2021-04-30\"],\"n_students\":[3,10,4,3]},\"columns\":[{\"accessor\":\".details\",\"name\":\"\",\"type\":\"NULL\",\"sortable\":false,\"resizable\":false,\"filterable\":false,\"width\":45,\"align\":\"center\",\"details\":[{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[1,1,1],\"s_id\":[4,5,14],\"s_name\":[\"Student D\",\"Student E\",\"Student N\"],\"gender\":[\"X\",\"Y\",\"Y\"],\"age\":[22,19,21]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"course_id\",\"type\":\"numeric\",\"show\":false},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":90,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"bordered\":true,\"compact\":true,\"dataKey\":\"12036566002706ab50f66831a92eae32\",\"key\":\"12036566002706ab50f66831a92eae32\",\"nested\":true},\"children\":[]},{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[2,2,2,2,2,2,2,2,2,2],\"s_id\":[6,7,8,9,10,13,15,17,18,19],\"s_name\":[\"Student F\",\"Student G\",\"Student H\",\"Student I\",\"Student J\",\"Student M\",\"Student O\",\"Student Q\",\"Student R\",\"Student S\"],\"gender\":[\"Y\",\"Y\",\"X\",\"Z\",\"Z\",\"Y\",\"Y\",\"Z\",\"X\",\"X\"],\"age\":[25,20,18,27,28,21,35,22,21,19]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"course_id\",\"type\":\"numeric\",\"show\":false},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":90,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"bordered\":true,\"compact\":true,\"dataKey\":\"6587f2ad3dcb0fcc5216bf4473c986a0\",\"key\":\"6587f2ad3dcb0fcc5216bf4473c986a0\",\"nested\":true},\"children\":[]},{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[3,3,3,3],\"s_id\":[1,3,12,16],\"s_name\":[\"Student A\",\"Student C\",\"Student L\",\"Student P\"],\"gender\":[\"X\",\"X\",\"X\",\"Z\"],\"age\":[21,30,25,30]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"course_id\",\"type\":\"numeric\",\"show\":false},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":90,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"bordered\":true,\"compact\":true,\"dataKey\":\"e3963514a17cdadfff8af46fde214632\",\"key\":\"e3963514a17cdadfff8af46fde214632\",\"nested\":true},\"children\":[]},{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"course_id\":[4,4,4],\"s_id\":[2,11,20],\"s_name\":[\"Student B\",\"Student K\",\"Student T\"],\"gender\":[\"X\",\"X\",\"Z\"],\"age\":[22,32,35]},\"columns\":[{\"accessor\":\"course_id\",\"name\":\"course_id\",\"type\":\"numeric\",\"show\":false},{\"accessor\":\"s_id\",\"name\":\"SID\",\"type\":\"numeric\",\"width\":70,\"align\":\"center\"},{\"accessor\":\"s_name\",\"name\":\"Student Name\",\"type\":\"character\"},{\"accessor\":\"gender\",\"name\":\"Gender\",\"type\":\"character\",\"width\":90,\"align\":\"center\"},{\"accessor\":\"age\",\"name\":\"Age\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"bordered\":true,\"compact\":true,\"dataKey\":\"5a3a2a276df6d52409d68b95331871bb\",\"key\":\"5a3a2a276df6d52409d68b95331871bb\",\"nested\":true},\"children\":[]}]},{\"accessor\":\"course_id\",\"name\":\"CID\",\"type\":\"numeric\",\"width\":50,\"align\":\"center\"},{\"accessor\":\"course_name\",\"name\":\"Course Name\",\"type\":\"character\"},{\"accessor\":\"start_date\",\"name\":\"Start Date\",\"type\":\"Date\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"end_date\",\"name\":\"End Date\",\"type\":\"Date\",\"width\":120,\"align\":\"center\"},{\"accessor\":\"n_students\",\"name\":\"No. of Students\",\"type\":\"numeric\",\"width\":130,\"align\":\"center\"}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":10,\"paginationType\":\"numbers\",\"showPageInfo\":true,\"minRows\":1,\"striped\":true,\"compact\":true,\"dataKey\":\"3be6d4b7204585a544def72d52d37613\",\"key\":\"3be6d4b7204585a544def72d52d37613\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}\r\nSince the sub-table is also a {reactable}, you can go\r\nanother level down… and another, but please do consider the usability\r\naspect of this feature before taking that decision. I haven’t tried\r\ngoing beyond 2 levels of data myself. Maybe a part 2 to this post??\r\nConclusion\r\nDrill-down tables let you pack a lot of data in a compact manner and\r\nallow use by multiple audiences interested in varying degrees/levels of\r\ninformation. {reactable} can help create an interactive\r\ndata table from tabular data with sorting and pagination by default. The\r\ndata table is an HTML widget that can be used in R Markdown documents\r\nand Shiny applications, or viewed from an R console. A lot of features\r\ncan be enabled/disabled using the basic arguments of the\r\nreactable() function and much more using custom\r\nJavaScript.\r\nReferences & Citations\r\nGreg Lin (2020). reactable: Interactive Data Tables Based on ‘React\r\nTable’. R package version 0.2.3. https://CRAN.R-project.org/package=reactable\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-07-27-drilldown/images/drilldown.gif",
    "last_modified": "2022-05-04T22:25:23+05:30",
    "input_file": {}
  },
  {
    "path": "posts/2021-07-17-programmingwithdplyr/",
    "title": "Programming with R {dplyr} - As I Understand It!!",
    "description": "How to create your own functions using {dplyr}",
    "author": [
      {
        "name": "Vishal Katti",
        "url": {}
      }
    ],
    "date": "2021-07-17",
    "categories": [
      "Rstats",
      "dplyr",
      "functions"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nInspiration\r\nData\r\n\r\nselect()\r\nPassing raw column\r\nnames\r\nPassing\r\nmultiple raw column names using … argument\r\nPassing a\r\ncharacter vector of column names\r\n\r\nfilter()\r\nPassing single raw\r\ncriteria\r\nPassing\r\nmultiple raw criteria using … argument\r\nPassing\r\nsingle criteria as a character string\r\nPassing\r\nmultiple criteria as character vector\r\n\r\nmutate()\r\nPassing the column\r\nname as raw name\r\nPassing\r\nthe new variable name as character string (direct)\r\nPassing\r\nthe new variable name as character string (indirect)\r\n\r\narrange()\r\nPassing single raw name\r\nPassing\r\nmultiple raw names using ... argument\r\nPass single column name\r\nas string\r\nPass multiple column\r\nname as string\r\n\r\ngroup_by()\r\nPassing single raw\r\nname\r\nPassing\r\nmultiple raw names using the ... operator\r\nPassing\r\nsingle or multiple column names as character string\r\n\r\n(Slightly Better) Examples\r\nmutate() example\r\ngroup_by() example\r\nMore ideas\r\n\r\nConclusion\r\nReferences\r\n\r\nIntroduction\r\nThe purpose of this document is to act as a quick guide for myself\r\nand others to understand how to use dplyr effectively to\r\ncreate dynamic functions. The general assumption is that the reader is\r\nfamiliar with the {dplyr} package and how to use it for\r\ndata wrangling.\r\nIn this document, we will explore how to create functions using the\r\npopular dplyr verbs like select,\r\nfilter, mutate, arrange and\r\nfinally group_by with summarise.\r\nInspiration\r\nI regularly deal with event-related information with event date and\r\nfew other columns like event type, root cause etc. Most reports usually\r\ninvolve calculating number of events that took place on a monthly,\r\nquarterly or annual basis, sometimes split by event type, root cause and\r\nother columns. After a few reports I realized that I am basically\r\nwriting the same code over and over again to calculate these KPIs.\r\nKeeping the DRY (Don't Repeat Yourself) principle in mind,\r\nI managed to write a few functions to calculate these KPIs with a few\r\ndynamic variables. Following is an attempt to articulate what I learnt\r\nwhile creating those functions.\r\nData\r\nWe shall use the Texas Housing Sales data, available as a tibble in\r\nthe popular ggplot2 package as reference data. It contains\r\nmonthly information about the housing market in Texas provided by the\r\nTAMU real estate center, https://www.recenter.tamu.edu/. It has 8602 observations\r\nand 9 variables.\r\n\r\n\r\ntxhousing <- ggplot2::txhousing\r\ndplyr::glimpse(txhousing)\r\n\r\n\r\nRows: 8,602\r\nColumns: 9\r\n$ city      <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abile~\r\n$ year      <int> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 20~\r\n$ month     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4,~\r\n$ sales     <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100~\r\n$ volume    <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 1391~\r\n$ median    <dbl> 71400, 58700, 58100, 68600, 67300, 66900, 73500, 7~\r\n$ listings  <dbl> 701, 746, 784, 785, 794, 780, 742, 765, 771, 764, ~\r\n$ inventory <dbl> 6.3, 6.6, 6.8, 6.9, 6.8, 6.6, 6.2, 6.4, 6.5, 6.6, ~\r\n$ date      <dbl> 2000.000, 2000.083, 2000.167, 2000.250, 2000.333, ~\r\n\r\nWe shall refer the above data in all the following sections.\r\nselect()\r\nWhen using dplyr functions, the two most popular ways to\r\npass column names is either as bare names i.e. column names without\r\nenclosing them in quotes like sales or volume\r\nOR pass them as a character string like “sales” or ‘volume’. You could\r\nalso pass a character vector like c(\"sales\", \"volume\"). In\r\nthis section we will explore the 3 ways to dynamically select the\r\ncolumns we want.\r\nPassing raw column names\r\nIn this method, we pass the raw name of the column we want to select\r\nand use the embrace of curly-curly brackets to pass the raw\r\nname. For multiple columns, we can pass the raw names as a single\r\nvector.\r\n\r\n\r\nselect_raw <- function(df, var) {\r\n  dplyr::select(.data = df, {{var}}) %>%     # embrace of curly-curly {{}} brackets\r\n    head()                                   # to limit the number of output rows in this example.\r\n}\r\nselect_raw(txhousing, sales)                 # pass single raw name\r\n\r\n\r\n# A tibble: 6 x 1\r\n  sales\r\n  <dbl>\r\n1    72\r\n2    98\r\n3   130\r\n4    98\r\n5   141\r\n6   156\r\n\r\nselect_raw(txhousing, c(sales, volume))      # pass a vector of raw names for multiple columns\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nIf passing multiple raw names as vector as in the\r\nselect_raw() feels like an unnecessary complication, try\r\nthe next method.\r\nPassing\r\nmultiple raw column names using … argument\r\nIn this method, we use the … argument to pass the raw\r\nnames of the columns we want to select.\r\n\r\n\r\nmy_select <- function(df, ...) {\r\n  dplyr::select(.data = df, ...) %>% \r\n    head()\r\n}\r\n\r\nmy_select(txhousing, sales, volume)          # pass multiple raw names directly\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nPassing a character\r\nvector of column names\r\nIf we have the column names as a character vector, we use the\r\nall_of function to pass the character vector to the\r\ninternal select function.\r\n\r\n\r\nmy_select_char <- function(df, cols) {\r\n  dplyr::select(.data = df, dplyr::all_of(cols)) %>% \r\n    head()\r\n}\r\n\r\nmy_cols <- c(\"sales\",\"volume\")\r\nmy_select_char(txhousing, my_cols)\r\n\r\n\r\n# A tibble: 6 x 2\r\n  sales   volume\r\n  <dbl>    <dbl>\r\n1    72  5380000\r\n2    98  6505000\r\n3   130  9285000\r\n4    98  9730000\r\n5   141 10590000\r\n6   156 13910000\r\n\r\nfilter()\r\nIn the previous section, we passed column names either as bare names\r\nor character strings. filter() takes one or more\r\nexpressions/conditions that result in a logical vector, with same length\r\nas number of rows in the data.frame/tibble and returns only those rows\r\nfor which the expression/condition returns TRUE. Following\r\nare 2 ways to pass these logical expressions/conditions. I’m using\r\nexpression and condition interchangeably here. In this context, a\r\ncondition is an expression that results in a boolean\r\nTRUE/FALSE result.\r\nPassing single raw criteria\r\nIn this method, we pass the condition sales > 8000 as\r\na raw/bare expression.\r\n\r\n\r\nfilter_raw <- function(df, cond) {\r\n  dplyr::filter(.data = df, {{cond}})        # embrace of curly-curly {{}} brackets\r\n}\r\n\r\nfilter_raw(txhousing, sales > 8000)          # Pass a single raw criterion\r\n\r\n\r\n# A tibble: 10 x 9\r\n   city     year month sales    volume median listings inventory  date\r\n   <chr>   <int> <int> <dbl>     <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.\r\n 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.\r\n 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.\r\n 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.\r\n 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.\r\n 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.\r\n 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.\r\n 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.\r\n 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.\r\n10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.\r\n\r\nDo you think we can pass multiple bare conditions as a vector, like\r\nwe did for select_raw() in the previous section? Let us try\r\npassing multiple raw criteria as a vector.\r\n\r\n\r\nfilter_raw(txhousing, c(sales > 8000, year > 2010))\r\n\r\n\r\nError in `dplyr::filter()`:\r\n! Problem while computing `..1 = c(sales > 8000, year >\r\n  2010)`.\r\nx Input `..1` must be of size 8602 or 1, not size 17204.\r\n\r\n\r\nPassing multiple raw criteria as a vector doesn’t work like it works\r\nfor select_raw() function. Let us understand why. Consider\r\nthe following code:\r\n\r\n\r\nA <- c(TRUE, TRUE)                           # boolean vector of length = 2\r\nB <- c(FALSE, FALSE)                         # boolean vector of length = 2\r\nX <- c(A, B)\r\nX\r\n\r\n\r\n[1]  TRUE  TRUE FALSE FALSE\r\n\r\nNotice that length of X is 4. Similarly, sales > 8000\r\nevaluates to a TRUE/FALSE boolean vector of length 8602 (equal to number\r\nof rows in txhousing) and so does\r\nyear > 2010. So the vector\r\nc(sales > 8000, year > 2010) becomes a TRUE/FALSE\r\nboolean vector of length 17204, which results in an error.\r\nPassing multiple\r\nraw criteria using … argument\r\nTo pass multiple raw criteria, we can use the ...\r\nargument.\r\n\r\n\r\nmy_filter <- function(df, ...) { \r\n  dplyr::filter(.data = df, ...)                # pass the dots argument\r\n  }\r\n\r\nmy_filter(txhousing, sales > 8000, year > 2010) # pass multiple raw criteria\r\n\r\n\r\n# A tibble: 8 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\r\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\r\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\r\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n\r\nPassing single\r\ncriteria as a character string\r\nBy default, dplyr::filter() does not accept conditions\r\nas character strings. Following is an example which results in error\r\n\r\n\r\ndplyr::filter(txhousing, \"sales > 8000\")\r\n\r\n\r\nError in `dplyr::filter()`:\r\n! Problem while computing `..1 = \"sales > 8000\"`.\r\nx Input `..1` must be a logical vector, not a character.\r\n\r\n\r\nWe need to convert the character condition into a raw expression.\r\n\r\n\r\nmy_filter_string <- function(df, cond) {\r\n  dplyr::filter(.data = df, eval(parse(text = cond)))   # convert text to raw criterion\r\n}\r\n\r\nmy_filter_string(txhousing, \"sales > 8000\")             # pass single text string as criteria\r\n\r\n\r\n# A tibble: 10 x 9\r\n   city     year month sales    volume median listings inventory  date\r\n   <chr>   <int> <int> <dbl>     <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.\r\n 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.\r\n 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.\r\n 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.\r\n 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.\r\n 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.\r\n 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.\r\n 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.\r\n 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.\r\n10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.\r\n\r\nThe special sauce here is the eval(parse(text = ...))\r\ncombo that converts the long text criteria into a single raw criteria\r\nand passes it to the internal filter() function.\r\nPassing multiple\r\ncriteria as character vector\r\nWhat if want to pass multiple criteria as a string vector? In such a\r\nsituation, we must combine all the string conditions into a single long\r\nstring condition using paste0(..., collapse = \" & \").\r\nThe paste0(\"(\", cond, \")\", collapse = \" & \") combines\r\nall the criteria into a single long criteria, but still a text\r\nstring.\r\n\r\n\r\nmy_filter_strings <- function(df, cond) { \r\n  filter_text <- paste0(\"(\", cond, \")\", collapse = \" & \")   # combine all criteria\r\n  message(\"Filter Condition: \", filter_text)                # (OPTIONAL) show the combined filter string\r\n  dplyr::filter(.data = df, eval(parse(text = filter_text)))# convert text to raw criterion\r\n  }\r\n\r\nmy_filter_criteria <- c(\"sales > 8000\", \"year > 2010\")\r\nmy_filter_strings(txhousing, my_filter_criteria)\r\n\r\n\r\n# A tibble: 8 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\r\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\r\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\r\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n\r\n\r\n\r\nmy_filter_criteria_with_OR <- c(\"sales > 8000 | sales < 50\", \"year > 2010\")\r\n\r\n# NOTE: OR criteria must be a single string separated by pipe '|' as in example below.\r\nmy_filter_strings(txhousing, my_filter_criteria_with_OR)\r\n\r\n\r\n# A tibble: 315 x 9\r\n   city        year month sales volume median listings inventory  date\r\n   <chr>      <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n 1 Brownsvil~  2011     1    48 4.97e6  83300      784      12.6 2011 \r\n 2 Brownsvil~  2011     2    47 5.56e6 101400      776      12.7 2011.\r\n 3 Brownsvil~  2011     7    47 4.81e6  91200      749      13.1 2012.\r\n 4 Brownsvil~  2011    12    39 4.20e6  86800      726      12.4 2012.\r\n 5 Brownsvil~  2012     1    43 3.89e6  85000      791      13.6 2012 \r\n 6 Brownsvil~  2012     3    27 2.98e6  93800      734      13.3 2012.\r\n 7 Brownsvil~  2012    11    41 5.12e6  99000      807      14   2013.\r\n 8 Brownsvil~  2013    11    38 4.82e6 108000      859      13.4 2014.\r\n 9 Brownsvil~  2015     1    41 5.40e6  97000      733      10.7 2015 \r\n10 Galveston   2011     1    43 8.88e6 170000     1015      13.7 2011 \r\n# ... with 305 more rows\r\n\r\nmutate()\r\nmutate() allows you to add new columns or modify\r\nexisting columns. In the example below, we will create a new column\r\nvolume_in_millions from the existing column\r\nvolume. The names of both the columns can be passed to the\r\nfunction either as raw names or character strings.\r\nPassing the column name as\r\nraw name\r\n\r\n\r\nmutate_raw <- function(df, new_col_raw, old_col_raw, num = 1) { \r\n  dplyr::mutate(.data = df, {{new_col_raw}} := {{old_col_raw}}/num) %>% \r\n    head()\r\n}\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>% \r\n  mutate_raw(vol_in_millions, volume, 1E6) # pass raw column names w/o quotes\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\nPassing\r\nthe new variable name as character string (direct)\r\n\r\n\r\nmutate_text <- function(df, new_col_str, old_col_str, num = 1) { \r\n  dplyr::mutate(.data = df, {{new_col_str}} := df[[old_col_str]]/num) %>% \r\n    head()\r\n}\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>%\r\n  mutate_text(\"vol_in_millions\", \"volume\", 1E6) # pass column names as strings\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\nPassing\r\nthe new variable name as character string (indirect)\r\nInstead of passing the name of the variable as a character string as\r\nan argument, we can pass a variable containing the name of the variable.\r\nIn the below example, the name of the new variable is stored in\r\nnew_var. Using the new {glue} syntax, enabled\r\nby the walrus operator :=, we substitute the\r\nnew_var variable with its value.\r\n\r\n\r\nmutate_var <- function(df, new_col_var, old_col_var, num = 1) {\r\n  dplyr::mutate(.data = df, \"{new_col_var}\" := df[[old_col_var]]/num) %>% \r\n    head()\r\n}\r\n\r\nnew_var <- \"vol_in_millions\"\r\nold_var <- \"volume\"\r\n\r\ntxhousing %>% \r\n  select(city, year, month, volume) %>%\r\n  mutate_var(new_var, old_var, 1E6)  # pass column names as variables\r\n\r\n\r\n# A tibble: 6 x 5\r\n  city     year month   volume vol_in_millions\r\n  <chr>   <int> <int>    <dbl>           <dbl>\r\n1 Abilene  2000     1  5380000            5.38\r\n2 Abilene  2000     2  6505000            6.50\r\n3 Abilene  2000     3  9285000            9.28\r\n4 Abilene  2000     4  9730000            9.73\r\n5 Abilene  2000     5 10590000           10.6 \r\n6 Abilene  2000     6 13910000           13.9 \r\n\r\narrange()\r\narrange() sorts the rows of a data frame by the values\r\nof selected columns. By default, it sorts in Ascending order. To force a\r\ncolumn to sort in Descending order, we must use the desc()\r\nfunction.\r\nPassing single raw name\r\n\r\n\r\narrange_raw <- function(df, var) {\r\n  dplyr::arrange(.data = df, {{var}}) %>%    # embrace of curly-curly {{}} brackets\r\n    head()\r\n}\r\n\r\narrange_raw(txhousing, sales)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.\r\n2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.\r\n3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 \r\n4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 \r\n5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.\r\n6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.\r\n\r\narrange_raw(txhousing, desc(sales))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\r\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n\r\narrange_raw() fails when we pass multiple raw names as a\r\nvector.\r\n\r\n\r\narrange_raw(txhousing, c(sales, volume))\r\n\r\n\r\nError in `dplyr::arrange()`:\r\n! Problem with the implicit `transmute()` step.\r\nx Problem while computing `..1 = c(sales, volume)`.\r\nx `..1` must be size 8602 or 1, not 17204.\r\n\r\n\r\nPassing multiple\r\nraw names using ... argument\r\nTo pass multiple raw names, we must use the ...\r\nargument.\r\n\r\n\r\narrange_raw_multiple <- function(df, ...) {\r\n  dplyr::arrange(.data = df, ...) %>% \r\n    head()\r\n}\r\n\r\narrange_raw_multiple(txhousing, city, sales)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales  volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Abilene  2003     1    68 5385000  70000      668       5.4  2003\r\n2 Abilene  2011     1    68 8834493 123300      809       6.1  2011\r\n3 Abilene  2009     1    70 8414801  92900      861       6.3  2009\r\n4 Abilene  2000     1    72 5380000  71400      701       6.3  2000\r\n5 Abilene  2010     1    73 9130783 112200      868       6.4  2010\r\n6 Abilene  2001     1    75 5730000  64500      779       6.8  2001\r\n\r\narrange_raw_multiple(txhousing, city, desc(sales))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales   volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>    <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Abilene  2015     7   268 45845730 148700      986       5   2016.\r\n2 Abilene  2015     6   260 41396230 141500      965       5   2015.\r\n3 Abilene  2007     7   239 29315000 114300      940       5.2 2008.\r\n4 Abilene  2013     8   236 30777727 120000      976       5.4 2014.\r\n5 Abilene  2014     7   231 35861350 145800     1033       5.8 2014.\r\n6 Abilene  2005     6   230 24050000  92500      664       4.1 2005.\r\n\r\nPass single column name as\r\nstring\r\n\r\n\r\narrange_str <- function(df, var, .desc = FALSE) {\r\n  if (.desc) {\r\n    dplyr::arrange(.data = df, desc(df[[var]])) %>% head()\r\n  } else {\r\n    dplyr::arrange(.data = df, df[[var]]) %>% head()\r\n  }\r\n}\r\n\r\narrange_str(txhousing, \"sales\")\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.\r\n2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.\r\n3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 \r\n4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 \r\n5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.\r\n6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.\r\n\r\narrange_str(txhousing, \"sales\", .desc = TRUE)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city     year month sales     volume median listings inventory  date\r\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\r\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\r\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\r\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\r\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\r\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\r\n\r\nPass multiple column name\r\nas string\r\n\r\n\r\narrange_str_multiple <- function(df, var, desc = FALSE) {\r\n  if (desc) {\r\n    dplyr::arrange(.data = df, desc(df[var])) %>% head()\r\n  } else {\r\n    dplyr::arrange(.data = df, df[var]) %>% head()\r\n  }\r\n}\r\n\r\n# This function arranges the dataframe either all ascending\r\n# or all descending. Definitely need a better example.\r\n\r\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"))\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Paris        2000     1    19 1.44e6  71700      286       7.5  2000\r\n2 San Marcos   2000     1    22 2.38e6 106700      190       6.3  2000\r\n3 Lufkin       2000     1    28 2.28e6  68000       NA      NA    2000\r\n4 Harlingen    2000     1    31 3.91e6  87500      644      24.9  2000\r\n5 Galveston    2000     1    37 4.56e6  95000      636       9.1  2000\r\n6 Port Arthur  2000     1    40 3.09e6  68300      314       5.6  2000\r\n\r\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"), desc = TRUE)\r\n\r\n\r\n# A tibble: 6 x 9\r\n  city         year month sales volume median listings inventory  date\r\n  <chr>       <int> <int> <dbl>  <dbl>  <dbl>    <dbl>     <dbl> <dbl>\r\n1 Houston      2015     7  8945 2.57e9 217600    23875       3.4 2016.\r\n2 Dallas       2015     7  7038 2.02e9 233000    12292       2.4 2016.\r\n3 Austin       2015     7  3466 1.15e9 264600     7913       3   2016.\r\n4 San Antonio  2015     7  2962 7.05e8 198100     9462       4.1 2016.\r\n5 Collin Cou~  2015     7  1861 6.14e8 292600     2809       2.1 2016.\r\n6 Fort Bend    2015     7  1372 4.32e8 280400     3328       3.1 2016.\r\n\r\ngroup_by()\r\nIn group_by(), we select which columns to,\r\nwell, group by! (Damn these well-named functions!). So one can use the\r\nsame techniques as select() to choose the columns.\r\nIn the following examples, we will create only one summarised value\r\ntotal_sales for simplicity.\r\nPassing single raw name\r\n\r\n\r\ngroup_raw <- function(df, grp) {\r\n  df %>% \r\n    group_by({{grp}}) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_raw(txhousing, year)        # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw(txhousing, month)       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 2\r\n  month total_sales\r\n  <int>       <dbl>\r\n1     1      245924\r\n2     2      296410\r\n3     3      386909\r\n4     4      397332\r\n5     5      448968\r\n\r\nPassing\r\nmultiple raw names using the ... operator\r\n\r\n\r\ngroup_raw_multiple <- function(df, ...) {\r\n  df %>% \r\n    group_by(...) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n = 5)\r\n}\r\n\r\ngroup_raw_multiple(txhousing, year)              # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw_multiple(txhousing, year, month)       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\nPassing\r\nsingle or multiple column names as character string\r\n\r\n\r\ngroup_str <- function(df, grp) {\r\n  df %>% \r\n    group_by(df[grp]) %>% \r\n    summarise(total_sales = sum(sales, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_str(txhousing, \"year\")                   # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_str(txhousing, c(\"year\", \"month\"))       # Sum of sales per month\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\n# The same column names can be passed as variables containing the character names\r\nyr <- \"year\"\r\ngroup_str(txhousing, yr)\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\nyrmon <- c(\"year\", \"month\")\r\ngroup_str(txhousing, yrmon)\r\n\r\n\r\n# A tibble: 5 x 3\r\n   year month total_sales\r\n  <int> <int>       <dbl>\r\n1  2000     1       11411\r\n2  2000     2       15674\r\n3  2000     3       20202\r\n4  2000     4       18658\r\n5  2000     5       22388\r\n\r\nIf you want the summarise column to have a custom name like\r\ntotal_<sumvar>, then you can wrap the value in quotes\r\nas below. This method uses the glue syntax enabled by the\r\n:= walrus operator. The walrus operator takes either a raw\r\nname or a character string on its LHS.\r\n\r\n\r\ngroup_raw2 <- function(df, grp, sumvar) {\r\n  df %>% \r\n    group_by({{grp}}) %>% \r\n    summarise(\"total_{{sumvar}}\" := sum({{sumvar}}, na.rm = TRUE),\r\n              .groups = 'drop')  %>% \r\n    head(n=5)\r\n}\r\n\r\ngroup_raw2(txhousing, year, sales)            # Sum of sales per year\r\n\r\n\r\n# A tibble: 5 x 2\r\n   year total_sales\r\n  <int>       <dbl>\r\n1  2000      222483\r\n2  2001      231453\r\n3  2002      234600\r\n4  2003      253909\r\n5  2004      283999\r\n\r\ngroup_raw2(txhousing, month, listings)        # Sum of listings per month\r\n\r\n\r\n# A tibble: 5 x 2\r\n  month total_listings\r\n  <int>          <dbl>\r\n1     1        1854661\r\n2     2        1888104\r\n3     3        1949187\r\n4     4        1991278\r\n5     5        2038932\r\n\r\nAfter writing so many examples, I see a pattern.\r\ngroup_by() works with techniques similar to\r\nselect() while summarise() works with\r\ntechniques similar to mutate().\r\n(Slightly Better) Examples\r\nThe txhousing is a city-wise monthly sales and volume\r\ndataset. It has a year and month column. Let\r\nus create a date column and keep only those columns\r\nrelevant for our custom tx_summary() function.\r\n\r\n\r\nsmall_df <- txhousing %>% \r\n  mutate(date = lubridate::as_date(glue::glue(\"{year}-{month}-01\"))) %>% \r\n  select(city, date, sales, volume)\r\n\r\n\r\n\r\nmutate() example\r\nNow let us create the create_ymq() function. This\r\nfunction would take 2 arguments, a data frame df and a raw\r\nname of a date column.\r\n\r\n\r\ncreate_ymq <- function(df, date_col) {\r\n  stopifnot(inherits(df, \"data.frame\"))\r\n  stopifnot(class(df %>% dplyr::pull({{date_col}})) == 'Date')\r\n  dplyr::mutate(df,\r\n                Year = lubridate::year({{date_col}}),\r\n                nHalf = lubridate::semester({{date_col}}),\r\n                yHalf = lubridate::semester({{date_col}}, with_year = TRUE),\r\n                dHalf = paste0(lubridate::semester({{date_col}}), \"H\", format({{date_col}},\"%y\")),\r\n                nQtr = lubridate::quarter({{date_col}}),\r\n                yQtr = lubridate::quarter({{date_col}}, with_year = TRUE),\r\n                dQtr = paste0(lubridate::quarter({{date_col}}),\"Q\", format({{date_col}},\"%y\")),\r\n                Month = lubridate::month({{date_col}}),\r\n                yMonth = as.numeric(format({{date_col}}, \"%Y.%m\")),\r\n                dMonth = format({{date_col}}, \"%b %Y\")\r\n                )\r\n}\r\n\r\ncreate_ymq(df = small_df, date_col = date) %>% glimpse()\r\n\r\n\r\nRows: 8,602\r\nColumns: 14\r\n$ city   <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\"~\r\n$ date   <date> 2000-01-01, 2000-02-01, 2000-03-01, 2000-04-01, 2000~\r\n$ sales  <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100, 9~\r\n$ volume <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 1391000~\r\n$ Year   <dbl> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,~\r\n$ nHalf  <int> 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,~\r\n$ yHalf  <dbl> 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.~\r\n$ dHalf  <chr> \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"2H00~\r\n$ nQtr   <int> 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2,~\r\n$ yQtr   <dbl> 2000.1, 2000.1, 2000.1, 2000.2, 2000.2, 2000.2, 2000.~\r\n$ dQtr   <chr> \"1Q00\", \"1Q00\", \"1Q00\", \"2Q00\", \"2Q00\", \"2Q00\", \"3Q00~\r\n$ Month  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5,~\r\n$ yMonth <dbl> 2000.01, 2000.02, 2000.03, 2000.04, 2000.05, 2000.06,~\r\n$ dMonth <chr> \"Jan 2000\", \"Feb 2000\", \"Mar 2000\", \"Apr 2000\", \"May ~\r\n\r\ngroup_by() example\r\nNow that we have a function that creates various date-related\r\ncolumns, let us create a function that let’s you create summary tables\r\nlike annual sales per city, quarterly volumes per city etc.\r\n\r\n\r\ntx_summary <- function(df, grp_col, sum_col) {\r\n  df %>% \r\n    group_by(city, {{grp_col}}) %>% \r\n    summarise(\"total_{{sum_col}}\" := sum({{sum_col}}, na.rm = TRUE), .groups = 'drop')\r\n}\r\n\r\n\r\n\r\nUsing these 2 functions, we can now create multiple summary\r\ntables\r\n\r\n\r\nsmall_df_with_date_cols <- small_df %>% create_ymq(date_col = date)\r\n\r\n# Annual Sales per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = Year, sum_col = sales)\r\n\r\n\r\n# A tibble: 736 x 3\r\n   city     Year total_sales\r\n   <chr>   <dbl>       <dbl>\r\n 1 Abilene  2000        1375\r\n 2 Abilene  2001        1431\r\n 3 Abilene  2002        1516\r\n 4 Abilene  2003        1632\r\n 5 Abilene  2004        1830\r\n 6 Abilene  2005        1977\r\n 7 Abilene  2006        1997\r\n 8 Abilene  2007        2003\r\n 9 Abilene  2008        1651\r\n10 Abilene  2009        1634\r\n# ... with 726 more rows\r\n\r\n# Half Yearly volumes per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yHalf, sum_col = volume)\r\n\r\n\r\n# A tibble: 1,472 x 3\r\n   city    yHalf total_volume\r\n   <chr>   <dbl>        <dbl>\r\n 1 Abilene 2000.     55400000\r\n 2 Abilene 2000.     53175000\r\n 3 Abilene 2001.     55795000\r\n 4 Abilene 2001.     58570000\r\n 5 Abilene 2002.     55305000\r\n 6 Abilene 2002.     63370000\r\n 7 Abilene 2003.     58175000\r\n 8 Abilene 2003.     77500000\r\n 9 Abilene 2004.     74205000\r\n10 Abilene 2004.     85465000\r\n# ... with 1,462 more rows\r\n\r\n# Quarterly Sales per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yQtr, sum_col = sales)\r\n\r\n\r\n# A tibble: 2,898 x 3\r\n   city     yQtr total_sales\r\n   <chr>   <dbl>       <dbl>\r\n 1 Abilene 2000.         300\r\n 2 Abilene 2000.         395\r\n 3 Abilene 2000.         387\r\n 4 Abilene 2000.         293\r\n 5 Abilene 2001.         305\r\n 6 Abilene 2001.         394\r\n 7 Abilene 2001.         401\r\n 8 Abilene 2001.         331\r\n 9 Abilene 2002.         295\r\n10 Abilene 2002.         425\r\n# ... with 2,888 more rows\r\n\r\n# Monthly Volumes per city\r\nsmall_df_with_date_cols %>% tx_summary(grp_col = yMonth, sum_col = volume)\r\n\r\n\r\n# A tibble: 8,602 x 3\r\n   city    yMonth total_volume\r\n   <chr>    <dbl>        <dbl>\r\n 1 Abilene  2000.      5380000\r\n 2 Abilene  2000.      6505000\r\n 3 Abilene  2000.      9285000\r\n 4 Abilene  2000.      9730000\r\n 5 Abilene  2000.     10590000\r\n 6 Abilene  2000.     13910000\r\n 7 Abilene  2000.     12635000\r\n 8 Abilene  2000.     10710000\r\n 9 Abilene  2000.      7615000\r\n10 Abilene  2000.      7040000\r\n# ... with 8,592 more rows\r\n\r\nMore ideas\r\nYou could further extend this by creating a custom filtering function\r\nthat gives you, say, the rows with the highest or lowest\r\ntotal_sales or total_volume.\r\nConclusion\r\nThe ability to create such dynamic functions, enabled by the\r\nwonderful {dplyr} package, allows us to level-up in terms of programming\r\nwith R and helps make our code neat and tidy.\r\nHow I feel while creating custom\r\nfunctions with {dplyr}! I can almost hear the music! Source:\r\ngifer.comReferences\r\nHadley Wickham, Romain François, Lionel Henry and Kirill Müller\r\n(2021). dplyr: A Grammar of Data Manipulation. R package version 1.0.7.\r\nhttps://CRAN.R-project.org/package=dplyr\r\nhttps://dplyr.tidyverse.org/articles/programming.html\r\nGarrett Grolemund, Hadley Wickham (2011). Dates and Times Made Easy\r\nwith lubridate. Journal of Statistical Software, 40(3), 1-25. URL https://www.jstatsoft.org/v40/i03/.\r\nH. Wickham. ggplot2: Elegant Graphics for Data Analysis.\r\nSpringer-Verlag New York, 2016.\r\nJim Hester (2020). glue: Interpreted String Literals. R package\r\nversion 1.4.2. https://CRAN.R-project.org/package=glue\r\n\r\n\r\n\r\n",
    "preview": "https://i.gifer.com/8inO.gif",
    "last_modified": "2022-05-04T20:39:22+05:30",
    "input_file": {}
  }
]
