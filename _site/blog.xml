<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:distill="https://distill.pub/journal/" version="2.0">
  <channel>
    <title>Vishal Katti</title>
    <link>https://vishalkatti.com</link>
    <atom:link href="https://vishalkatti.com/blog.xml" rel="self" type="application/rss+xml"/>
    <description>Welcome to Vishal Katti's website
</description>
    <generator>Distill</generator>
    <lastBuildDate>Sun, 28 Aug 2022 00:00:00 +0000</lastBuildDate>
    <item>
      <title>Pivoting your tables with Tidyr: Part II</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2022-08-29-tidyrpivotwider</link>
      <description>


&lt;h1 id="intro"&gt;Intro&lt;/h1&gt;
&lt;p&gt;This is part 2 of the Pivoting your tables with Tidyr series. Read
Part 1 &lt;a
href="https://www.vishalkatti.com/posts/2022-07-08-tidyrpivotlonger/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We discussed the advantages of using the long format during data
analysis, most users feel that the wide format is more readable by
human. This is why most reports tend to have the data arranged in the
wide format.&lt;/p&gt;
&lt;p&gt;The wide format has at least one column which acts as a primary key
i.e. it is unique and each value appears only once. It can also have
multiple column whose unique combination acts as a primary key i.e. each
combination appears only once.&lt;/p&gt;
&lt;p&gt;Read more about wide vs. long formats &lt;a
href="https://www.statology.org/long-vs-wide-data/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While the long format is preferred and is desirable for data and
plotting operations using R, Python or other data processing programming
languages, the wide format is more human-readable. The {tidyr} R package
has functions that allow you to transform your tabular data between the
two formats.&lt;/p&gt;
&lt;p&gt;In this post, we will see how to convert a long dataframe to wide
format using the &lt;em&gt;pivot_wider()&lt;/em&gt; function from {tidyr}
package.&lt;/p&gt;
&lt;h1 id="the-long-one"&gt;The long one&lt;/h1&gt;
&lt;p&gt;Consider the following data table. It has been created from the
famous Gapminder dataset. This table shows the average life expectancy
in each continent for 2 years. While some of you may say that Gapminder
data contains records for a lot more number of years, here we consider
just the latest 2 years for ease of explanation and visual purposes.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://vishalkatti.com/posts/2022-08-29-tidyrpivotwiderimages/Step1.png" alt="" /&gt;
&lt;p class="caption"&gt;Continent-wise Average Life Expectancy over last 2
years&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;my_data&lt;/code&gt; is in the long format as we have continent names
and year in their own column and average life expectancy values for each
unique combination of year and continent. If we want to compare life
expectancy across years for each continent, we need to have the life
expectancy values for each continent side-by-side for easier viewing
i.e. we need to convert to the wide format. To convert this tibble to
the wide format, we need to push the &lt;code&gt;year&lt;/code&gt; values into the
headers and the &lt;code&gt;average_life_expectancy&lt;/code&gt; values under the
corresponding year column.&lt;/p&gt;
&lt;h1 id="the-wide-one"&gt;The wide one&lt;/h1&gt;
&lt;p&gt;The long format of this table would ideally have only
&lt;code&gt;year&lt;/code&gt;, &lt;code&gt;continent&lt;/code&gt; and
&lt;code&gt;average_life_expectancy&lt;/code&gt; columns and look something like the
table below.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://vishalkatti.com/posts/2022-08-29-tidyrpivotwiderimages/Step2.png" style="width:60.0%" /&gt;&lt;/p&gt;
&lt;p&gt;The wide format has unique values of the column that are not pushed
into headers. In this case, the &lt;code&gt;continent&lt;/code&gt; column becomes
unique for each row.&lt;/p&gt;
&lt;p&gt;Let’s recreate the above transformation in R. First, we create the
&lt;code&gt;my_data&lt;/code&gt; table.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_data &amp;lt;- data.frame(
  id = 1:10,
  year = c(2002L, 2002L, 2002L, 2002L, 2002L, 2007L, 2007L, 2007L, 2007L, 2007L), 
continent = c(&amp;quot;Africa&amp;quot;, &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Europe&amp;quot;, &amp;quot;Oceania&amp;quot;, &amp;quot;Africa&amp;quot;, &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Europe&amp;quot;, 
&amp;quot;Oceania&amp;quot;), 
average_life_expectancy = c(53.33, 72.42, 69.23, 76.7, 79.74, 54.81, 73.61, 70.73, 77.65, 80.72)
)

knitr::kable(my_data)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;id&lt;/th&gt;
&lt;th align="right"&gt;year&lt;/th&gt;
&lt;th align="left"&gt;continent&lt;/th&gt;
&lt;th align="right"&gt;average_life_expectancy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;1&lt;/td&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2&lt;/td&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;3&lt;/td&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;4&lt;/td&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;6&lt;/td&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;7&lt;/td&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;9&lt;/td&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;10&lt;/td&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To convert this table into wide format, we use the
&lt;em&gt;pivot_wider()&lt;/em&gt; function from {tidyr} R package. Let us see how
to use this function.&lt;/p&gt;
&lt;p&gt;💡&lt;em&gt;Tip: use &lt;code&gt;formals&lt;/code&gt; to view all the formal arguments
of a function and their default values. &lt;code&gt;formals&lt;/code&gt; returns a
named list.&lt;/em&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tidyr, quietly = TRUE, warn.conflicts = FALSE)

formals(pivot_wider)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$data


$id_cols
NULL

$id_expand
[1] FALSE

$names_from
name

$names_prefix
[1] &amp;quot;&amp;quot;

$names_sep
[1] &amp;quot;_&amp;quot;

$names_glue
NULL

$names_sort
[1] FALSE

$names_vary
[1] &amp;quot;fastest&amp;quot;

$names_expand
[1] FALSE

$names_repair
[1] &amp;quot;check_unique&amp;quot;

$values_from
value

$values_fill
NULL

$values_fn
NULL

$unused_fn
NULL

$...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of &lt;code&gt;formals(pivot_wider)&lt;/code&gt; tells us that the
minimum information needed to use this function is to provide values to
the &lt;code&gt;data&lt;/code&gt;,&lt;code&gt;names_from&lt;/code&gt; and
&lt;code&gt;values_from&lt;/code&gt; arguments as all other arguments have default
values and hence, are optional.&lt;/p&gt;
&lt;p&gt;Using only the minimum arguments with &lt;code&gt;pivot_wider()&lt;/code&gt;, we
get a wide formatted tibble but with missing data!&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;wide_minimal &amp;lt;- pivot_wider(
                        data        = my_data,
                        names_from  = year,
                        values_from = average_life_expectancy
                        )

knitr::kable(wide_minimal)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;id&lt;/th&gt;
&lt;th align="left"&gt;continent&lt;/th&gt;
&lt;th align="right"&gt;2002&lt;/th&gt;
&lt;th align="right"&gt;2007&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;1&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;3&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;4&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;6&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;7&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;9&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;10&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;So why did &lt;code&gt;NA&lt;/code&gt;s appear in the result?
&lt;code&gt;pivot_wider()&lt;/code&gt; creates unique combinations of all columns
not included in &lt;code&gt;names_from&lt;/code&gt; or &lt;code&gt;values_from&lt;/code&gt;
argument. Therefore, if your dataframe/tibble had a primary key prior to
the transformation, the primary key of your transformed “wide” dataframe
is your old primary key + unique combinations of all columns not
included in &lt;code&gt;names_from&lt;/code&gt; or &lt;code&gt;values_from&lt;/code&gt;
argument. This gives an unusable output with &lt;code&gt;NA&lt;/code&gt;s. To
specify which column/s to be made unique, pass their name to the
&lt;code&gt;id_cols&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_data_longer &amp;lt;- pivot_wider(
                        data        = my_data,
                        id_cols     = continent, 
                        names_from  = year,
                        values_from = average_life_expectancy
                        )

knitr::kable(my_data_longer)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="left"&gt;continent&lt;/th&gt;
&lt;th align="right"&gt;2002&lt;/th&gt;
&lt;th align="right"&gt;2007&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If you are a visual person like me and wish to see this
transformation with explanations, check out this GIF I made using good
ol’ Powerpoint.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://vishalkatti.com/posts/2022-08-29-tidyrpivotwiderimages/pivot_wider.gif" alt="" /&gt;
&lt;p class="caption"&gt;{tidyr} pivot_wider() explained&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;pivot_wider()&lt;/code&gt; is the successor for the great
&lt;code&gt;spread()&lt;/code&gt; function and has many advantages over the latter.
This function has many other arguments that allow some truly great
transformations. Mastering this function (and its long counterpart) is a
great skill upgrade while massaging your data to make it “tidy”.&lt;/p&gt;
&lt;p&gt;Happy Spreading!&lt;/p&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.statology.org/long-vs-wide-data/"&gt;Long vs. Wide
Data: What’s the Difference?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hadley Wickham and Maximilian Girlich (2022). tidyr: Tidy Messy
Data. R package version 1.2.0. &lt;a
href="https://CRAN.R-project.org/package=tidyr"
class="uri"&gt;https://CRAN.R-project.org/package=tidyr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Yihui Xie (2022). knitr: A General-Purpose Package for Dynamic
Report Generation in R. R package version 1.39.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>20e5cc552204b7b19505e435df6485ab</distill:md5>
      <category>Rstats</category>
      <category>functions</category>
      <category>tidyr</category>
      <category>pivot</category>
      <guid>https://vishalkatti.com/posts/2022-08-29-tidyrpivotwider</guid>
      <pubDate>Sun, 28 Aug 2022 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2022-08-29-tidyrpivotwider/images/pivot_wider.gif" medium="image" type="image/gif"/>
    </item>
    <item>
      <title>Pivoting your tables with Tidyr: Part I</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2022-07-08-tidyrpivotlonger</link>
      <description>


&lt;h1 id="intro"&gt;Intro&lt;/h1&gt;
&lt;p&gt;One of the primary data manipulation operations is pivoting your
tabular data from “wide” format to “long” format and vice-versa.&lt;/p&gt;
&lt;p&gt;The idea is to make your tabular data “tidy” i.e.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every column is a variable.&lt;/li&gt;
&lt;li&gt;Every row is an observation.&lt;/li&gt;
&lt;li&gt;Every cell is a single value.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words, every column contains just one type of information,
every row in the table is a snapshot or a version of the information
your table captures and every cell contains just one piece of
information. Read more about wide vs. long formats &lt;a
href="https://www.statology.org/long-vs-wide-data/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While the wide format is more human-readable, the long format is
preferred and is desirable for data and plotting operations using R,
Python or other data processing programming languages. The {tidyr} R
package has functions that allow you to transform your tabular data
between the two formats.&lt;/p&gt;
&lt;p&gt;In this post, we will see how to convert a wide dataframe to long
format using the &lt;em&gt;pivot_longer()&lt;/em&gt; function from {tidyr}
package.&lt;/p&gt;
&lt;h1 id="the-wide-one"&gt;The wide one&lt;/h1&gt;
&lt;p&gt;Consider the following data table. It has been created from the
famous Gapminder dataset. This table shows the average life expectancy
in each continent for 2 years. While some of you may say that Gapminder
data contains records for a lot more number of years, here we consider
just the latest 2 years for ease of explanation and visual purposes.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://vishalkatti.com/posts/2022-07-08-tidyrpivotlongerimages/Step1.png" alt="" /&gt;
&lt;p class="caption"&gt;Continent-wise Average Life Expectancy over last 2
years&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;my_data&lt;/code&gt; is in the wide format as we have continent names
in column headers and average life expectancy values in each of those
columns. To convert this tibble to the long format, we need to pull
together the continent names in one column and their corresponding
values into another column.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://vishalkatti.com/posts/2022-07-08-tidyrpivotlongerimages/Step2.png" /&gt;&lt;/p&gt;
&lt;h1 id="the-long-one"&gt;The long one&lt;/h1&gt;
&lt;p&gt;The long format of this table would ideally have only
&lt;code&gt;year&lt;/code&gt;, &lt;code&gt;continent&lt;/code&gt; and
&lt;code&gt;average_life_expectancy&lt;/code&gt; columns and look something like the
table below.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://vishalkatti.com/posts/2022-07-08-tidyrpivotlongerimages/Step3.png" style="width:60.0%" /&gt;&lt;/p&gt;
&lt;p&gt;The long format has repeated values of the column that are not
gathered/collected. In this case, the &lt;code&gt;year&lt;/code&gt; column gets its
values repeated for each row.&lt;/p&gt;
&lt;p&gt;Let’s recreate the above transformation in R. First, we create the
&lt;code&gt;my_data&lt;/code&gt; table.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_data &amp;lt;- data.frame(
  year     = c(2002L, 2007L), 
  Africa   = c(53.33, 54.81), 
  Americas = c(72.42, 73.61), 
  Asia     = c(69.23, 70.73), 
  Europe   = c(76.70, 77.65), 
  Oceania  = c(79.74, 80.72)
)

knitr::kable(my_data)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;year&lt;/th&gt;
&lt;th align="right"&gt;Africa&lt;/th&gt;
&lt;th align="right"&gt;Americas&lt;/th&gt;
&lt;th align="right"&gt;Asia&lt;/th&gt;
&lt;th align="right"&gt;Europe&lt;/th&gt;
&lt;th align="right"&gt;Oceania&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;To convert this table into long format, we use the
&lt;em&gt;pivot_longer()&lt;/em&gt; function from {tidyr} R package. Let us see how
to use this function.&lt;/p&gt;
&lt;p&gt;💡&lt;em&gt;Tip: use &lt;code&gt;formals&lt;/code&gt; to view all the formal arguments
of a function and their default values. &lt;code&gt;formals&lt;/code&gt; returns a
named list.&lt;/em&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tidyr, quietly = TRUE, warn.conflicts = FALSE)

formals(pivot_longer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$data


$cols


$names_to
[1] &amp;quot;name&amp;quot;

$names_prefix
NULL

$names_sep
NULL

$names_pattern
NULL

$names_ptypes
NULL

$names_transform
NULL

$names_repair
[1] &amp;quot;check_unique&amp;quot;

$values_to
[1] &amp;quot;value&amp;quot;

$values_drop_na
[1] FALSE

$values_ptypes
NULL

$values_transform
NULL

$...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of &lt;code&gt;formals(pivot_longer)&lt;/code&gt; tells us that the
minimum information needed to use this function is to provide values to
the &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;cols&lt;/code&gt; arguments as all other
arguments have default values and hence, are optional.&lt;/p&gt;
&lt;p&gt;Using only the minimum arguments with &lt;code&gt;pivot_longer()&lt;/code&gt;, we
get a long formatted tibble with the columns &lt;code&gt;year&lt;/code&gt;,
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;long_minimal &amp;lt;- pivot_longer(
                        data      = my_data,
                        cols      = c(&amp;quot;Africa&amp;quot;, &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Europe&amp;quot;, &amp;quot;Oceania&amp;quot;)
                        )

knitr::kable(long_minimal)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;year&lt;/th&gt;
&lt;th align="left"&gt;name&lt;/th&gt;
&lt;th align="right"&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Notice that the continent names and their corresponding average life
expectancy values appear in columns named &lt;code&gt;name&lt;/code&gt; and
&lt;code&gt;value&lt;/code&gt;. These are the default column names. We can change
these column names by providing our own names to the arguments
&lt;code&gt;names_to&lt;/code&gt; and &lt;code&gt;values_to&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since the &lt;code&gt;year&lt;/code&gt; column is the only one that remains as
is, we can rewrite the above &lt;code&gt;pivot_longer&lt;/code&gt; statement as
below&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_data_longer &amp;lt;- pivot_longer(data      = my_data,
                               cols      = !year,
                               names_to  = &amp;quot;continent&amp;quot;,
                               values_to = &amp;quot;average_life_expectancy&amp;quot;)

knitr::kable(my_data_longer)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;year&lt;/th&gt;
&lt;th align="left"&gt;continent&lt;/th&gt;
&lt;th align="right"&gt;average_life_expectancy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;53.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;72.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;69.23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;76.70&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2002&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;79.74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Africa&lt;/td&gt;
&lt;td align="right"&gt;54.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Americas&lt;/td&gt;
&lt;td align="right"&gt;73.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Asia&lt;/td&gt;
&lt;td align="right"&gt;70.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Europe&lt;/td&gt;
&lt;td align="right"&gt;77.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;2007&lt;/td&gt;
&lt;td align="left"&gt;Oceania&lt;/td&gt;
&lt;td align="right"&gt;80.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If you are a visual person like me and wish to see this
transformation with explanations, check out this GIF I made using good
ol’ Powerpoint.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://vishalkatti.com/posts/2022-07-08-tidyrpivotlongerimages/pivot_longer.gif" alt="" /&gt;
&lt;p class="caption"&gt;{tidyr} pivot_longer() explained&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;pivot_longer()&lt;/code&gt; is the successor for the great
&lt;code&gt;gather()&lt;/code&gt; function and has many advantages over the latter.
&lt;code&gt;pivot_longer()&lt;/code&gt; repeats all the values in the columns that
are not included in the &lt;code&gt;cols&lt;/code&gt; argument. Therefore, if your
dataframe/tibble had a primary key prior to the transformation, the
primary key of your transformed “longer” dataframe is your old primary
key + the new column created by &lt;code&gt;names_to&lt;/code&gt;. This function has
many other arguments that allow some truly great transformations.
Mastering this function (and its wide counterpart) is a great skill
upgrade while massaging your data to make it “tidy”.&lt;/p&gt;
&lt;p&gt;Happy Gathering!&lt;/p&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.statology.org/long-vs-wide-data/"&gt;Long vs. Wide
Data: What’s the Difference?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hadley Wickham and Maximilian Girlich (2022). tidyr: Tidy Messy
Data. R package version 1.2.0. &lt;a
href="https://CRAN.R-project.org/package=tidyr"
class="uri"&gt;https://CRAN.R-project.org/package=tidyr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Yihui Xie (2022). knitr: A General-Purpose Package for Dynamic
Report Generation in R. R package version 1.39.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>599d54321c9d66febfc54acf8fc5e540</distill:md5>
      <category>Rstats</category>
      <category>functions</category>
      <category>tidyr</category>
      <category>pivot</category>
      <guid>https://vishalkatti.com/posts/2022-07-08-tidyrpivotlonger</guid>
      <pubDate>Fri, 08 Jul 2022 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2022-07-08-tidyrpivotlonger/images/pivot_longer.gif" medium="image" type="image/gif"/>
    </item>
    <item>
      <title>Writing Robust R Functions</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2022-01-18-writingrobustrfunctions</link>
      <description>


&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Functions in R ( or any other programming language in general) allow
us to encapsulate some lines of code that we want to run again and
again. Functions are the natural outcome of the &lt;strong&gt;DRY&lt;/strong&gt;
(Don’t Repeat Yourself!) principle. Functions group together a couple of
lines of consistent logic making our code modular and consequently, easy
to manage. However, when we write functions, we need to ensure that they
behave exactly as we want them to and are able to handle whatever we
throw at them. By whatever, I mean any and all kinds of inputs. The idea
of creating unbreakable code is idealistic. I say this since creating
robust functions requires additional code to handle the unwanted inputs
and most useRs write functions during some one-time analysis. Hence we
need to be pragmatic about how much time and effort we spend trying to
make our functions robust. Maybe, we need our functions to be just
robust enough! All I am saying is, if you are creating functions that
will be used by you and only you i.e. if you have absolute control over
what inputs would be provided to your functions, then you can forego
certain checks and the functions need not be unbreakable. But, if you
intend to write functions that will be used by a larger audience, you
need to ensure that such functions are able to handle all kinds of
innocent and malicious intents.&lt;/p&gt;
&lt;h2 id="what-do-we-mean-by-robust-functions"&gt;What do we mean by Robust
Functions?&lt;/h2&gt;
&lt;p&gt;You must be familiar with the &lt;em&gt;Garbage-In-Garbage-Out&lt;/em&gt;
philosophy of Software engineering. We can think of it in terms of
functions, that, given garbage or bad input, you get garbage or bad
output. For a function to be robust, it must behave in a consistent
manner for known and correct inputs, however, more importantly, it
mustn’t give us garbage for bad inputs. Rather, it must provide useful
output (as messages or instructions) which can be further used to inform
the end-user about possible problems in the inputs to drive proper
usage. The useful output/s in case of bad inputs would ideally be a
combination of clean early exit and easy-to-understand error messages.
So we shall try to implement &lt;em&gt;Garbage-In-Useful-Info-Out&lt;/em&gt; by
looking at some ways we can build well-behaved and reliable
functions.&lt;/p&gt;
&lt;p&gt;Input values passed to a function are more popularly known as
arguments or parameters. A robust function must validate the function
arguments before proceeding to implement the function logic. If this is
not done, then the bad arguments will cause some errors in the logic and
display error messages that the end-user may not be familiar with.
Worst-case scenario is when the function doesn’t encounter any errors
and just gives bad results!! Surely, we do not want this unpredictable
behavior.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://i.imgflip.com/28bxz3.jpg" style="width:60.0%"
alt="" /&gt;
&lt;p class="caption"&gt;Enough Talk, Let’s Fight! - Kungfu Panda
@imgflip.com&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="our-sweet-innocent-and-naive-function"&gt;Our sweet, innocent and
naive Function&lt;/h2&gt;
&lt;p&gt;Consider the following function &lt;code&gt;make_date&lt;/code&gt; that takes 3
numeric inputs &lt;code&gt;yyyy&lt;/code&gt;, &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;dd&lt;/code&gt;
and returns a single ’Date` object.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm, dd) {
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

my_date &amp;lt;- make_date(yyyy = 2022, mm = 1, dd = 31)
my_date&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;2022-01-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;class(my_date)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;Date&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will use &lt;code&gt;make_date&lt;/code&gt; to demonstrate a couple of
scenarios where this function can fail and the methods to safeguard
against such scenarios.&lt;/p&gt;
&lt;h2 id="scenario-1-missing-arguments"&gt;Scenario 1: Missing Arguments&lt;/h2&gt;
&lt;p&gt;The most basic check we should perform before running the function
logic is to confirm if all the required arguments are available. Think
about how your function should behave if one of the arguments, suppose
&lt;code&gt;mm&lt;/code&gt; is missing.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, dd = 31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in paste(yyyy, mm, dd, sep = "-"): argument "mm" is missing, with no default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the error message shown to the user, is triggered, not from
our function &lt;code&gt;make_date&lt;/code&gt; but from the internal
&lt;code&gt;paste&lt;/code&gt; function. We do not have any control over what error
messages are shown when errors occur. In this case, we know specifically
that this error is due to a missing argument.&lt;/p&gt;
&lt;p&gt;There are two ways to handle missing arguments:&lt;/p&gt;
&lt;h3 id="early-exit"&gt;1.1 Early Exit&lt;/h3&gt;
&lt;p&gt;If a certain required argument is missing, we can stop the execution
of the function and show informative error message about which argument
is missing. Your friends here are the &lt;code&gt;missing&lt;/code&gt; and
&lt;code&gt;stop&lt;/code&gt; functions. The &lt;code&gt;missing&lt;/code&gt; function checks if
the given argument is missing or is set to NULL and returns TRUE, else
it returns FALSE. The &lt;code&gt;stop&lt;/code&gt; function stops the execution and
displays the custom error message we provide. Using these functions
inside an &lt;code&gt;if&lt;/code&gt; condition will let us check for missing
arguments. Let us modify our naive function to stop early when required
arguments are missing.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm, dd) {
  
  # check missing arguments
  if (missing(yyyy)) stop(&amp;quot;argument `yyyy` is required.&amp;quot;)
  if (missing(mm))   stop(&amp;quot;argument `mm` is required.&amp;quot;)
  if (missing(dd))   stop(&amp;quot;argument `dd` is required.&amp;quot;)
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

# Calling the function without `mm` argument
make_date(yyyy = 2022, dd = 31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, dd = 31): argument `mm` is required.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that here, we add three &lt;code&gt;if-missing-stop&lt;/code&gt; statements,
one for each required argument. We must do this if we want to display
specific error messages for each argument. There is another way to do
the same but we will look at it later. If we want to display a single
error message, we can do so by clubbing the &lt;code&gt;missing&lt;/code&gt;
functions inside an &lt;code&gt;any&lt;/code&gt; which will return TRUE if any one
of the arguments is missing. However, providing clear error messages
becomes challenging in this method.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_fun &amp;lt;- function(a, b, c) { 
  if(any(missing(a), missing(b), missing(c))) {
    stop(&amp;quot;One or more required arguments missing.&amp;quot;)
  }
  # Do something...
}
dummy_fun(a = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_fun(a = 1): One or more required arguments missing.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="sensible-defaults-with-warnings"&gt;1.2 Sensible defaults with
warnings&lt;/h3&gt;
&lt;p&gt;In some cases, we may need the function to use some sensible default
value for the required arguments and continue execution. Here, we
display a warning message instead of an error message. This is required
when the argument value is either considered to be obvious or the
argument is not necessarily the most important one and is used only in
extreme customization. &lt;strong&gt;Providing default values to arguments
makes them optional arguments&lt;/strong&gt;. An example of default argument
values can be seen in the &lt;code&gt;paste&lt;/code&gt; function we have used
earlier. The default value of the separator argument &lt;code&gt;sep&lt;/code&gt; is
a single whitespace character.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;args(paste)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;function (..., sep = &amp;quot; &amp;quot;, collapse = NULL, recycle0 = FALSE) 
NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we can provide some sensible defaults for the
&lt;code&gt;make_date&lt;/code&gt; function. Let’s modify the function further to
provide defaults for the &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;dd&lt;/code&gt; arguments
only.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

# Calling the function without `mm` and `dd` arguments
make_date(yyyy = 2022) # here, only `yyyy` is the required argument.&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in make_date(yyyy = 2022): argument `mm` is missing. Using
default value mm = 1 instead
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in make_date(yyyy = 2022): argument `dd` is missing. Using
default value dd = 1 instead
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;2022-01-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a few concerns about using warnings instead of error
messages. Some are listed here in this article from RBloggers &lt;a
href="https://www.r-bloggers.com/2012/05/a-warning-about-warning/"&gt;A
Warning About &lt;code&gt;warning&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="scenario-2-invalid-argument-data-type"&gt;Scenario 2: Invalid
Argument Data Type&lt;/h2&gt;
&lt;p&gt;We have defined &lt;code&gt;make_date&lt;/code&gt; to accept 3 numeric arguments
i.e. all 3 must be numbers. What would happen if someone tried to call
&lt;code&gt;make_date&lt;/code&gt; with character, factor or boolean inputs?&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = &amp;quot;2022&amp;quot;, mm = &amp;quot;5&amp;quot;, dd = &amp;quot;20&amp;quot;) # works!! why?&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;2022-05-20&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the function works because when the arguments are
combined into a single string using &lt;code&gt;paste&lt;/code&gt; , it matches the
&lt;code&gt;format&lt;/code&gt; argument of the &lt;code&gt;as.Date&lt;/code&gt; function in the
main logic of &lt;code&gt;make_date&lt;/code&gt; which is
&lt;code&gt;as.Date(paste(yyyy, mm, dd, sep = "-"), format = "%Y-%m-%d")&lt;/code&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = &amp;quot;2022&amp;quot;, mm = &amp;quot;May&amp;quot;, dd = &amp;quot;1&amp;quot;) # works but shows NA !!!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, all the arguments pass the checks but the output is
&lt;code&gt;NA&lt;/code&gt; since we pass &lt;code&gt;2022-May-1&lt;/code&gt; to
&lt;code&gt;as.Date&lt;/code&gt; which doesn’t match the
&lt;code&gt;format = '%Y-%m-%d'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;How do we check if the values provided to the arguments are numbers
or number-like? If the values are numbers, we let them pass. But if they
are non-numeric, we must check if they can be converted to numbers i.e.
we must check if they are number-like. By number-like, I mean, will
coercing the value using &lt;code&gt;as.numeric&lt;/code&gt; give us a numeric value
or &lt;code&gt;NA&lt;/code&gt; ? You guessed it right, we will pass the values
through &lt;code&gt;as.numeric&lt;/code&gt; and check if the output is
&lt;code&gt;NA&lt;/code&gt; or not.&lt;/p&gt;
&lt;p&gt;What are the various data types in R that are not
&lt;code&gt;numeric&lt;/code&gt; but can look like numbers? We have
&lt;code&gt;character&lt;/code&gt;, &lt;code&gt;factor&lt;/code&gt; and &lt;code&gt;boolean&lt;/code&gt;
data types which can behave like numbers sometimes. Let’s see a few
scenarios.&lt;/p&gt;
&lt;h3 id="character-arguments"&gt;Character arguments&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;Year &amp;lt;- c(&amp;quot;2022&amp;quot;, &amp;quot;TwentyTwo&amp;quot;)
Year_num &amp;lt;- as.numeric(Year) # this should show a warning about NAs introduced by coercion
Year_num # must show the number 2022 without quotes and one NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2022   NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see in above example, when passed through
&lt;code&gt;as.numeric&lt;/code&gt;, the value “2022” gets converted to the number
2022 but the value “TwentyTwo” does not. Hence we can say “2022” is
number-like but “TwentyTwo” is not.&lt;/p&gt;
&lt;h3 id="factor-arguments"&gt;Factor arguments&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;Year &amp;lt;- factor(c(&amp;quot;2022&amp;quot;,&amp;quot;2021&amp;quot;,&amp;quot;TwentyTwo&amp;quot;))
as.numeric(Year)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2 1 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;YearX &amp;lt;- factor(c(&amp;quot;2022&amp;quot;, &amp;quot;X&amp;quot;))
as.numeric(YearX)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 1 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;YearY &amp;lt;- factor(2022)
as.numeric(YearY)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see from above examples, &lt;code&gt;factor&lt;/code&gt; values do get
converted to numeric but do not give the right results. So we can safely
say that factors are not number-like.&lt;/p&gt;
&lt;p&gt;I will ignore &lt;code&gt;boolean&lt;/code&gt; data types hoping that useRs are
bright enough to not use Booleans while creating a Date!&lt;/p&gt;
&lt;p&gt;From the above examples, we can conclude that &lt;code&gt;numeric&lt;/code&gt;
values and number-like &lt;code&gt;character&lt;/code&gt; values are the only valid
data types that should be allowed. Modifying our &lt;code&gt;make_date&lt;/code&gt;
function to include data type checks.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  # Check data types
  if (!is.numeric(yyyy) &amp;amp; !is.character(yyyy)) {
    stop(&amp;quot;argument `yyyy` must be numeric&amp;quot;)
  } else if (is.character(yyyy) &amp;amp; is.na(as.numeric(yyyy))) {
    stop(&amp;quot;argument `yyyy` must be numeric&amp;quot;)
  }
  if (!is.numeric(mm) &amp;amp; !is.character(mm)) {
    stop(&amp;quot;argument `mm` must be numeric&amp;quot;)
  } else if (is.character(mm) &amp;amp; is.na(as.numeric(mm))) {
    stop(&amp;quot;argument `mm` must be numeric&amp;quot;)
  }
  if (!is.numeric(dd) &amp;amp; !is.character(dd)) {
    stop(&amp;quot;argument `dd` must be numeric&amp;quot;)
  } else if (is.character(dd) &amp;amp; is.na(as.numeric(dd))) {
    stop(&amp;quot;argument `dd` must be numeric&amp;quot;)
  }
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

# Calling the function with new datatype checks
make_date(yyyy = &amp;quot;2022&amp;quot;, mm = &amp;quot;May&amp;quot;, dd = &amp;quot;1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = "2022", mm = "May", dd = "1"): argument `mm` must be numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = &amp;quot;2022&amp;quot;, mm = factor(&amp;quot;5&amp;quot;), dd = &amp;quot;1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = "2022", mm = factor("5"), dd = "1"): argument `mm` must be numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the datatype check is lengthy and similar for all 3
arguments. We can apply &lt;strong&gt;DRY&lt;/strong&gt; principle again and
encapsulate that code into a small function &lt;code&gt;is_numberlike&lt;/code&gt;
which will return &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; . Note that
&lt;code&gt;is_numberlike&lt;/code&gt; has no checks because it is an internal
function.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# This function check if value is number or number-like.
is_numberlike &amp;lt;- function(x){
  if (!is.numeric(x) &amp;amp; !is.character(x)) {
    return(FALSE) # Early Exit 1 if value is neither numeric nor character
  } else if (is.character(x) &amp;amp; is.na(as.numeric(x))) {
    return(FALSE) # Early Exit 2 if character value is not number-like.
  }
  return(TRUE)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus our &lt;code&gt;make_date&lt;/code&gt; function with data types check will
look as below.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  # Check data types
  if (!is_numberlike(yyyy)) stop(&amp;quot;argument `yyyy` must be numeric&amp;quot;)
  if (!is_numberlike(mm))   stop(&amp;quot;argument `mm` must be numeric&amp;quot;)
  if (!is_numberlike(dd))   stop(&amp;quot;argument `dd` must be numeric&amp;quot;)
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

# Calling the function with new datatype checks
make_date(yyyy = &amp;quot;TwentyTwo&amp;quot;, mm = &amp;quot;5&amp;quot;, dd = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in is_numberlike(yyyy): NAs introduced by coercion
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = "TwentyTwo", mm = "5", dd = 1): argument `yyyy` must be numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = &amp;quot;2022&amp;quot;, mm = factor(&amp;quot;5&amp;quot;), dd = &amp;quot;1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = "2022", mm = factor("5"), dd = "1"): argument `mm` must be numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 5, dd = &amp;quot;one&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in is_numberlike(dd): NAs introduced by coercion
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 5, dd = "one"): argument `dd` must be numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the most interesting features of R is vectorization! Due to
this feature, our function &lt;code&gt;make_date&lt;/code&gt; behaves in interesting
ways. In some cases, it is desirable and sometimes it is not.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 1:12, dd = &amp;quot;1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; [1] &amp;quot;2022-01-01&amp;quot; &amp;quot;2022-02-01&amp;quot; &amp;quot;2022-03-01&amp;quot; &amp;quot;2022-04-01&amp;quot; &amp;quot;2022-05-01&amp;quot;
 [6] &amp;quot;2022-06-01&amp;quot; &amp;quot;2022-07-01&amp;quot; &amp;quot;2022-08-01&amp;quot; &amp;quot;2022-09-01&amp;quot; &amp;quot;2022-10-01&amp;quot;
[11] &amp;quot;2022-11-01&amp;quot; &amp;quot;2022-12-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the above warnings. These warnings appear because the
&lt;code&gt;if&lt;/code&gt; statement checks if the condition provided results in a
single &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; value. However, the
output of the check &lt;code&gt;is.na(as.numeric(mm))&lt;/code&gt; is a boolean
vector of length 12. But &lt;code&gt;if&lt;/code&gt; needs only 1 &lt;code&gt;TRUE&lt;/code&gt;
or &lt;code&gt;FALSE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The output contains 12 date values since &lt;code&gt;paste&lt;/code&gt; is
vectorised, it recycles the values for &lt;code&gt;yyyy&lt;/code&gt; and
&lt;code&gt;dd&lt;/code&gt; to give us 12 dates!&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;mm &amp;lt;- 1:12
paste(&amp;quot;Month&amp;quot;, mm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; [1] &amp;quot;Month 1&amp;quot;  &amp;quot;Month 2&amp;quot;  &amp;quot;Month 3&amp;quot;  &amp;quot;Month 4&amp;quot;  &amp;quot;Month 5&amp;quot;  &amp;quot;Month 6&amp;quot; 
 [7] &amp;quot;Month 7&amp;quot;  &amp;quot;Month 8&amp;quot;  &amp;quot;Month 9&amp;quot;  &amp;quot;Month 10&amp;quot; &amp;quot;Month 11&amp;quot; &amp;quot;Month 12&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What do we do if we want &lt;code&gt;make_date&lt;/code&gt; to return just one
date?&lt;/p&gt;
&lt;h2 id="scenario-3-incorrect-argument-size"&gt;Scenario 3: Incorrect
Argument Size&lt;/h2&gt;
&lt;p&gt;To ensure &lt;code&gt;make_date&lt;/code&gt; gives you just one date, we must
ensure that the arguments have just value and is not a vector of
multiple values i.e. &lt;code&gt;length(arg)==1&lt;/code&gt;. Let’s further add a
few checks for the data size of the arguments and rearrange the
checks.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  # Check argument lengths
  if (length(yyyy)!=1) stop(paste0(&amp;quot;Length of argument `yyyy` is &amp;quot;, length(yyyy),&amp;quot;. Must be only 1.&amp;quot;))
  if (length(mm)!=1)   stop(paste0(&amp;quot;Length of argument `mm` is &amp;quot;, length(mm),&amp;quot;. Must be only 1.&amp;quot;))
  if (length(dd)!=1)   stop(paste0(&amp;quot;Length of argument `dd` is &amp;quot;, length(dd),&amp;quot;. Must be only 1.&amp;quot;))
  
  # Check data types
  if (!is_numberlike(yyyy)) stop(&amp;quot;argument `yyyy` must be numeric&amp;quot;)
  if (!is_numberlike(mm))   stop(&amp;quot;argument `mm` must be numeric&amp;quot;)
  if (!is_numberlike(dd))   stop(&amp;quot;argument `dd` must be numeric&amp;quot;)
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

# Calling function with new data size checks
make_date(yyyy = 2022, mm = 1:12, dd = &amp;quot;01&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 1:12, dd = "01"): Length of argument `mm` is 12. Must be only 1.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = c(&amp;quot;2021&amp;quot;,&amp;quot;2022&amp;quot;), mm = &amp;quot;1&amp;quot;, dd = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = c("2021", "2022"), mm = "1", dd = 1): Length of argument `yyyy` is 2. Must be only 1.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 1, dd = c(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 1, dd = c("1", "2")): Length of argument `dd` is 2. Must be only 1.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="a-little-detour"&gt;A little detour…&lt;/h2&gt;
&lt;p&gt;So far we checked for missing arguments, arguments with bad data
types and arguments with incorrect sizes. We’ve used the
&lt;code&gt;stop&lt;/code&gt; function along with &lt;code&gt;if&lt;/code&gt; to check for all
failure conditions and show appropriate error messages. When we use
&lt;code&gt;stop&lt;/code&gt;, we must specify all the failure conditions and the
number of specific error messages goes up as number of arguments
increases.&lt;/p&gt;
&lt;p&gt;In case of our &lt;code&gt;make_date&lt;/code&gt;, if an argument is not missing,
it must be a number-like value of length 1. To reduce the number of
error messages, we can combine the error messages for data type and
length. for eg, the error message could be &lt;em&gt;argument
&lt;code&gt;yyyy&lt;/code&gt; must be a number-like value of length 1.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Wouldn’t it be easier if we just specify what is the success
condition aka the “happy path”, and show error for all other conditions?
To do this, we can use the &lt;code&gt;stopifnot&lt;/code&gt; function that let’s us
specify all the happy paths. See example below.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum &amp;lt;- function(a, b, c){
  
  # check missing
  stopifnot(!missing(a) &amp;amp; !missing(b) &amp;amp; !missing(c))
  
  # check argument values
  stopifnot(!is.na(a) &amp;amp; is.numeric(a) &amp;amp; length(a)==1,
            !is.na(b) &amp;amp; is.numeric(b) &amp;amp; length(b)==1,
            !is.na(c) &amp;amp; is.numeric(c) &amp;amp; length(c)==1
            )
  sum(a, b, c)
}

dummy_sum(b = 2, c = 3) # a is missing&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(b = 2, c = 3): !missing(a) &amp; !missing(b) &amp; !missing(c) is not TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = NA_integer_, b = 2, c = 3): !is.na(a) &amp; is.numeric(a) &amp; length(a) == 1 is not TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = 1, b = &amp;quot;2&amp;quot;, c = 3) # b has non-numeric value&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = 1, b = "2", c = 3): !is.na(b) &amp; is.numeric(b) &amp; length(b) == 1 is not TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = 1, b = 2, c = 5:7): !is.na(c) &amp; is.numeric(c) &amp; length(c) == 1 are not all TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the error messages above. They are not so user-friendly.
Luckily, we can specify error messages in &lt;code&gt;stopifnot&lt;/code&gt; by
providing the error messages as the names of the “happy path”
conditions.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum &amp;lt;- function(a, b, c){
  
  # check missing
  stopifnot(&amp;quot;one or more required arguments missing&amp;quot; = !missing(a) &amp;amp; !missing(b) &amp;amp; !missing(c))
  
  # check argument values
  stopifnot(&amp;quot;argument `a` must not be NA, must be a number of length 1&amp;quot; = !is.na(a) &amp;amp; is.numeric(a) &amp;amp; length(a)==1,
            &amp;quot;argument `b` must not be NA, must be a number of length 1&amp;quot; = !is.na(b) &amp;amp; is.numeric(b) &amp;amp; length(b)==1,
            &amp;quot;argument `c` must not be NA, must be a number of length 1&amp;quot; = !is.na(c) &amp;amp; is.numeric(c) &amp;amp; length(c)==1
            )
  sum(a, b, c)
}

dummy_sum(b = 2, c = 3) # a is missing&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(b = 2, c = 3): one or more required arguments missing
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = NA_integer_, b = 2, c = 3): argument `a` must not be NA, must be a number of length 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = 1, b = &amp;quot;2&amp;quot;, c = 3) # b has non-numeric value&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = 1, b = "2", c = 3): argument `b` must not be NA, must be a number of length 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;dummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in dummy_sum(a = 1, b = 2, c = 5:7): argument `c` must not be NA, must be a number of length 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;stopifnot&lt;/code&gt; in our &lt;code&gt;make_date&lt;/code&gt; function
to combine the datatype and length checks, we get…&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  
  # Check argument types and length
  stopifnot(
    &amp;quot;argument `yyyy` must be numeric with length 1&amp;quot; = is_numberlike(yyyy) &amp;amp; length(yyyy)==1,
    &amp;quot;argument `mm` must be numeric with length 1&amp;quot;   = is_numberlike(mm)   &amp;amp; length(mm)==1,
    &amp;quot;argument `dd` must be numeric with length 1&amp;quot;   = is_numberlike(dd)   &amp;amp; length(dd)==1
  )
  
  # main logic
  as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
}

make_date() # no arguments provided&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(): argument `yyyy` is required.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 1:12, dd = 31) # Length mm not equal to 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in if (is.character(x) &amp; is.na(as.numeric(x))) {: the
condition has length &gt; 1 and only the first element will be used
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 1:12, dd = 31): argument `mm` must be numeric with length 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = &amp;quot;Jan&amp;quot;, dd = 31) # mm is not number-like&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in is_numberlike(mm): NAs introduced by coercion
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = "Jan", dd = 31): argument `mm` must be numeric with length 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, dd = 31) # argument mm is missing but should work using default value&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: orange;"&gt;&lt;code&gt;Warning in make_date(yyyy = 2022, dd = 31): argument `mm` is missing.
Using default value mm = 1 instead
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;2022-01-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h2
id="scenario-4-values-of-arguments-that-result-in-invalid-outputs"&gt;Scenario
4: Values of Arguments that result in invalid outputs&lt;/h2&gt;
&lt;p&gt;Finally, what do we do when the arguments provided will definitely
give us bad results despite passing all checks? In our case,
&lt;code&gt;make_date&lt;/code&gt; creates a date but if we give it values that will
result in an invalid date, it will give us invalid results (remember
&lt;em&gt;Garbage-In-Garbage-Out&lt;/em&gt;?).&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get &lt;code&gt;NA&lt;/code&gt; because &lt;code&gt;as.Date&lt;/code&gt; returns NA for
invalid inputs with no error messages or warnings! We can check the
output and provide a generic error message.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date &amp;lt;-  function(yyyy, mm = 1, dd = 1) {
  # check missing arguments
  if (missing(yyyy))  stop(&amp;quot;argument `yyyy` is required.&amp;quot;) 
  if (missing(mm)) warning(&amp;quot;argument `mm` is missing. Using default value mm = 1 instead&amp;quot;) 
  if (missing(dd)) warning(&amp;quot;argument `dd` is missing. Using default value dd = 1 instead&amp;quot;)
  
  
  # Check argument types and length
  stopifnot(
    &amp;quot;argument `yyyy` must be numeric with length 1&amp;quot; = is_numberlike(yyyy) &amp;amp; length(yyyy)==1,
    &amp;quot;argument `mm` must be numeric with length 1&amp;quot;   = is_numberlike(mm)   &amp;amp; length(mm)==1,
    &amp;quot;argument `dd` must be numeric with length 1&amp;quot;   = is_numberlike(dd)   &amp;amp; length(dd)==1
  )
  
  # main logic
  out &amp;lt;- as.Date(paste(yyyy, mm, dd, sep = &amp;quot;-&amp;quot;), format = &amp;quot;%Y-%m-%d&amp;quot;)
  if (is.na(out)) {
    stop(&amp;quot;Invalid values provided. Please check your inputs.&amp;quot;)
  }
  return(out)
}

make_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 13, dd = 1): Invalid values provided. Please check your inputs.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;make_date(yyyy = 2022, mm = 2, dd = 31) # are there 31 days in February?&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in make_date(yyyy = 2022, mm = 2, dd = 31): Invalid values provided. Please check your inputs.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do you think our function &lt;code&gt;make_date&lt;/code&gt; is robust
enough?&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img
src="https://64.media.tumblr.com/f6dc1e64c3d63e1f308e46445cafb6ab/tumblr_mo7km0eiRW1qedb29o1_500.gif"
alt="" /&gt;
&lt;p class="caption"&gt;As robust as Superman! Source: Tumblr&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Making functions robust requires some prior thought about its
intended use and audience. Based on this, we can decide what checks to
implement, what to skip, whether to stop execution using error messages
or to use default values with warnings. Checking for “happy paths” is
simpler compared to checking each and every bad input and providing
specific error messages. Too many different error messages for the same
argument could become a source of frustration of the end user, so
consider combining some checks and their error messages to be
informative and precise. Robustness, like everything else, in
moderation, is good and getting it “just right” takes time and dedicated
effort. Happy Coding!&lt;/p&gt;
&lt;h2 id="citations-references"&gt;Citations &amp;amp; References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a
href="https://www.lexjansen.com/phuse/2014/ts/TS03.pdf"&gt;Techniques for
writing robust R programs - LexJansen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://bookdown.org/rdpeng/rprogdatascience/functions.html"&gt;R
Programming for Data Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://www.r-bloggers.com/2012/05/a-warning-about-warning/"&gt;A
Warning About warning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>d89192ac7a6e0017e1caacdbd7c8a643</distill:md5>
      <category>Rstats</category>
      <category>functions</category>
      <guid>https://vishalkatti.com/posts/2022-01-18-writingrobustrfunctions</guid>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      <media:content url="https://64.media.tumblr.com/f6dc1e64c3d63e1f308e46445cafb6ab/tumblr_mo7km0eiRW1qedb29o1_500.gif" medium="image" type="image/gif"/>
    </item>
    <item>
      <title>Unholy Trinity of R, Excel VBA and Powerpoint - Part 2 of 2</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2021-12-29-rtovbatoppt</link>
      <description>Using R to trigger Excel VBA macros to create PowerPoint presentations</description>
      <category>Rstats</category>
      <category>Excel</category>
      <category>VBA</category>
      <category>PowerPoint</category>
      <category>openxlsx</category>
      <category>RDCOMClient</category>
      <guid>https://vishalkatti.com/posts/2021-12-29-rtovbatoppt</guid>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2021-12-29-rtovbatoppt/images/R2XL2PPT_logo.png" medium="image" type="image/png" width="1500" height="619"/>
    </item>
    <item>
      <title>Unholy Trinity of R, Excel VBA and Powerpoint - Part 1 of 2</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2021-08-29-rtovbatoppt</link>
      <description>Using R to trigger Excel VBA macros to create PowerPoint presentations!</description>
      <category>Rstats</category>
      <category>Excel</category>
      <category>VBA</category>
      <category>PowerPoint</category>
      <guid>https://vishalkatti.com/posts/2021-08-29-rtovbatoppt</guid>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2021-08-29-rtovbatoppt/images/R2XL2PPT_logo.png" medium="image" type="image/png" width="1500" height="619"/>
    </item>
    <item>
      <title>Interactive Drill-down Tables using {reactable}</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2021-07-27-drilldown</link>
      <description>


&lt;p&gt;We often come across denormalized data that has 2 or more levels of
information. For example, top-level info like course info with data
fields like course id, course name, description, start/end date and
second-level info like student info with data fields like with student
id, student name, age and gender. We may also have these two groups of
data as separate tables with a primary-key foreign-key design, usually
from a well-designed SQL database.&lt;/p&gt;
&lt;p&gt;Let us create some data.&lt;/p&gt;
&lt;h2 id="top-level-data-course"&gt;Top-Level data:
&lt;strong&gt;course&lt;/strong&gt;&lt;/h2&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(rmarkdown, quietly = TRUE, warn.conflicts = FALSE)

course &amp;lt;- tibble(course_id           = 1:4,
                 course_name         = paste(&amp;quot;Course&amp;quot;, LETTERS[1:4]),
                 start_date          = seq.Date(from = lubridate::as_date(&amp;quot;2021-01-01&amp;quot;), by = &amp;quot;month&amp;quot;, length.out = 4),
                 end_date            = lubridate::ceiling_date(start_date, unit = &amp;quot;month&amp;quot;) - 1)

paged_table(course)&lt;/code&gt;&lt;/pre&gt;
&lt;div data-pagedtable="false"&gt;
&lt;script data-pagedtable-source type="application/json"&gt;
{"columns":[{"label":["course_id"],"name":[1],"type":["int"],"align":["right"]},{"label":["course_name"],"name":[2],"type":["chr"],"align":["left"]},{"label":["start_date"],"name":[3],"type":["date"],"align":["right"]},{"label":["end_date"],"name":[4],"type":["date"],"align":["right"]}],"data":[{"1":"1","2":"Course A","3":"2021-01-01","4":"2021-01-31"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31"},{"1":"4","2":"Course D","3":"2021-04-01","4":"2021-04-30"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  &lt;/script&gt;
&lt;/div&gt;
&lt;h2 id="second-level-data-student"&gt;Second Level Data:
&lt;strong&gt;student&lt;/strong&gt;&lt;/h2&gt;
&lt;pre class="r"&gt;&lt;code&gt;set.seed(42)
student &amp;lt;- tibble(s_id      = 1:20,
                  s_name    = paste(&amp;quot;Student&amp;quot;, LETTERS[1:20]),
                  gender    = sample(c(&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;,&amp;quot;Z&amp;quot;), 20, replace = TRUE),
                  age       = sample(18:35, 20, replace = TRUE),
                  course_id = sample(1:4, 20, replace = TRUE))

paged_table(student)&lt;/code&gt;&lt;/pre&gt;
&lt;div data-pagedtable="false"&gt;
&lt;script data-pagedtable-source type="application/json"&gt;
{"columns":[{"label":["s_id"],"name":[1],"type":["int"],"align":["right"]},{"label":["s_name"],"name":[2],"type":["chr"],"align":["left"]},{"label":["gender"],"name":[3],"type":["chr"],"align":["left"]},{"label":["age"],"name":[4],"type":["int"],"align":["right"]},{"label":["course_id"],"name":[5],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"Student A","3":"X","4":"21","5":"3"},{"1":"2","2":"Student B","3":"X","4":"22","5":"4"},{"1":"3","2":"Student C","3":"X","4":"30","5":"3"},{"1":"4","2":"Student D","3":"X","4":"22","5":"1"},{"1":"5","2":"Student E","3":"Y","4":"19","5":"1"},{"1":"6","2":"Student F","3":"Y","4":"25","5":"2"},{"1":"7","2":"Student G","3":"Y","4":"20","5":"2"},{"1":"8","2":"Student H","3":"X","4":"18","5":"2"},{"1":"9","2":"Student I","3":"Z","4":"27","5":"2"},{"1":"10","2":"Student J","3":"Z","4":"28","5":"2"},{"1":"11","2":"Student K","3":"X","4":"32","5":"4"},{"1":"12","2":"Student L","3":"X","4":"25","5":"3"},{"1":"13","2":"Student M","3":"Y","4":"21","5":"2"},{"1":"14","2":"Student N","3":"Y","4":"21","5":"1"},{"1":"15","2":"Student O","3":"Y","4":"35","5":"2"},{"1":"16","2":"Student P","3":"Z","4":"30","5":"3"},{"1":"17","2":"Student Q","3":"Z","4":"22","5":"2"},{"1":"18","2":"Student R","3":"X","4":"21","5":"2"},{"1":"19","2":"Student S","3":"X","4":"19","5":"2"},{"1":"20","2":"Student T","3":"Z","4":"35","5":"4"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;If we are sourcing data from a database, it is probable that you
would see these 2 levels of data in 2 separate tables/views, but most
business users are comfortable with MS Excel and want &lt;strong&gt;all the
data in one sheet&lt;/strong&gt;!!&lt;/p&gt;
&lt;p&gt;So the data actually looks something like this.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;combined_df &amp;lt;- left_join(course, student, by = &amp;quot;course_id&amp;quot;)

paged_table(combined_df)&lt;/code&gt;&lt;/pre&gt;
&lt;div data-pagedtable="false"&gt;
&lt;script data-pagedtable-source type="application/json"&gt;
{"columns":[{"label":["course_id"],"name":[1],"type":["int"],"align":["right"]},{"label":["course_name"],"name":[2],"type":["chr"],"align":["left"]},{"label":["start_date"],"name":[3],"type":["date"],"align":["right"]},{"label":["end_date"],"name":[4],"type":["date"],"align":["right"]},{"label":["s_id"],"name":[5],"type":["int"],"align":["right"]},{"label":["s_name"],"name":[6],"type":["chr"],"align":["left"]},{"label":["gender"],"name":[7],"type":["chr"],"align":["left"]},{"label":["age"],"name":[8],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"Course A","3":"2021-01-01","4":"2021-01-31","5":"4","6":"Student D","7":"X","8":"22"},{"1":"1","2":"Course A","3":"2021-01-01","4":"2021-01-31","5":"5","6":"Student E","7":"Y","8":"19"},{"1":"1","2":"Course A","3":"2021-01-01","4":"2021-01-31","5":"14","6":"Student N","7":"Y","8":"21"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"6","6":"Student F","7":"Y","8":"25"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"7","6":"Student G","7":"Y","8":"20"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"8","6":"Student H","7":"X","8":"18"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"9","6":"Student I","7":"Z","8":"27"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"10","6":"Student J","7":"Z","8":"28"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"13","6":"Student M","7":"Y","8":"21"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"15","6":"Student O","7":"Y","8":"35"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"17","6":"Student Q","7":"Z","8":"22"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"18","6":"Student R","7":"X","8":"21"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"19","6":"Student S","7":"X","8":"19"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31","5":"1","6":"Student A","7":"X","8":"21"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31","5":"3","6":"Student C","7":"X","8":"30"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31","5":"12","6":"Student L","7":"X","8":"25"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31","5":"16","6":"Student P","7":"Z","8":"30"},{"1":"4","2":"Course D","3":"2021-04-01","4":"2021-04-30","5":"2","6":"Student B","7":"X","8":"22"},{"1":"4","2":"Course D","3":"2021-04-01","4":"2021-04-30","5":"11","6":"Student K","7":"X","8":"32"},{"1":"4","2":"Course D","3":"2021-04-01","4":"2021-04-30","5":"20","6":"Student T","7":"Z","8":"35"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;Displaying such data in a table causes all the top-level data fields
to repeat for every second-level record. You can see that
&lt;code&gt;course_id&lt;/code&gt;, &lt;code&gt;course_name&lt;/code&gt;,
&lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; columns repeat for all
students who enrolled in the same course. Take a moment to think about
how would you display such data in an interactive table in a web page,
HTML report or Shiny app.&lt;/p&gt;
&lt;p&gt;It is advisable to split such denormalized data into normalized data
i.e. create the original top-level and second level tables from the
&lt;code&gt;combined_df&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="vanilla-reactable"&gt;Vanilla &lt;code&gt;reactable&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;One of my favorite R packages is &lt;code&gt;{reactable}&lt;/code&gt;. The
default output creates a neat interactive table with pagination (if data
has more than 10 rows) and ability to sort columns.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(reactable, quietly = TRUE, warn.conflicts = FALSE)

reactable(data = combined_df)&lt;/code&gt;&lt;/pre&gt;
&lt;div id="htmlwidget-0420b066e36ce9489c4b" class="reactable html-widget" style="width:auto;height:auto;"&gt;&lt;/div&gt;
&lt;script type="application/json" data-for="htmlwidget-0420b066e36ce9489c4b"&gt;{"x":{"tag":{"name":"Reactable","attribs":{"data":{"course_id":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],"course_name":["Course A","Course A","Course A","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course C","Course C","Course C","Course C","Course D","Course D","Course D"],"start_date":["2021-01-01","2021-01-01","2021-01-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-03-01","2021-03-01","2021-03-01","2021-03-01","2021-04-01","2021-04-01","2021-04-01"],"end_date":["2021-01-31","2021-01-31","2021-01-31","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-03-31","2021-03-31","2021-03-31","2021-03-31","2021-04-30","2021-04-30","2021-04-30"],"s_id":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],"s_name":["Student D","Student E","Student N","Student F","Student G","Student H","Student I","Student J","Student M","Student O","Student Q","Student R","Student S","Student A","Student C","Student L","Student P","Student B","Student K","Student T"],"gender":["X","Y","Y","Y","Y","X","Z","Z","Y","Y","Z","X","X","X","X","X","Z","X","X","Z"],"age":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},"columns":[{"accessor":"course_id","name":"course_id","type":"numeric"},{"accessor":"course_name","name":"course_name","type":"character"},{"accessor":"start_date","name":"start_date","type":"Date"},{"accessor":"end_date","name":"end_date","type":"Date"},{"accessor":"s_id","name":"s_id","type":"numeric"},{"accessor":"s_name","name":"s_name","type":"character"},{"accessor":"gender","name":"gender","type":"character"},{"accessor":"age","name":"age","type":"numeric"}],"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"dataKey":"413c1f3c101a174f7070712d78c69feb"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}&lt;/script&gt;
&lt;h2 id="basic-formatting"&gt;Basic Formatting&lt;/h2&gt;
&lt;p&gt;With some additional tweaks, we can make it look better.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;reactable(
  data       = combined_df,
  compact    = TRUE, # for minimum row height
  filterable = TRUE, # for individual column filters
  striped    = TRUE, # banded rows
  resizable  = TRUE, # for resizable column widths
  columns    = list( # define custom header name, width, alignment etc.
    course_id   = colDef(name = &amp;quot;CID&amp;quot;,         width = 50,  align = &amp;quot;center&amp;quot;),
    course_name = colDef(name = &amp;quot;Course Name&amp;quot;, width = 140),
    start_date  = colDef(name = &amp;quot;Start Date&amp;quot;,  width = 120, align = &amp;quot;center&amp;quot;),
    end_date    = colDef(name = &amp;quot;End Date&amp;quot;,    width = 120, align = &amp;quot;center&amp;quot;),
    s_id        = colDef(name = &amp;quot;SID&amp;quot;,         width = 70,  align = &amp;quot;center&amp;quot;),
    s_name      = colDef(name = &amp;quot;Student Name&amp;quot;),
    gender      = colDef(name = &amp;quot;Gender&amp;quot;,      width = 80,  align = &amp;quot;center&amp;quot;),
    age         = colDef(name = &amp;quot;Age&amp;quot;,         width = 50)
  )
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id="htmlwidget-d308ea22dc0f64dbf7ed" class="reactable html-widget" style="width:auto;height:auto;"&gt;&lt;/div&gt;
&lt;script type="application/json" data-for="htmlwidget-d308ea22dc0f64dbf7ed"&gt;{"x":{"tag":{"name":"Reactable","attribs":{"data":{"course_id":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],"course_name":["Course A","Course A","Course A","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course C","Course C","Course C","Course C","Course D","Course D","Course D"],"start_date":["2021-01-01","2021-01-01","2021-01-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-03-01","2021-03-01","2021-03-01","2021-03-01","2021-04-01","2021-04-01","2021-04-01"],"end_date":["2021-01-31","2021-01-31","2021-01-31","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-03-31","2021-03-31","2021-03-31","2021-03-31","2021-04-30","2021-04-30","2021-04-30"],"s_id":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],"s_name":["Student D","Student E","Student N","Student F","Student G","Student H","Student I","Student J","Student M","Student O","Student Q","Student R","Student S","Student A","Student C","Student L","Student P","Student B","Student K","Student T"],"gender":["X","Y","Y","Y","Y","X","Z","Z","Y","Y","Z","X","X","X","X","X","Z","X","X","Z"],"age":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},"columns":[{"accessor":"course_id","name":"CID","type":"numeric","width":50,"align":"center"},{"accessor":"course_name","name":"Course Name","type":"character","width":140},{"accessor":"start_date","name":"Start Date","type":"Date","width":120,"align":"center"},{"accessor":"end_date","name":"End Date","type":"Date","width":120,"align":"center"},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":80,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"striped":true,"compact":true,"dataKey":"37ac57f783425a81c3f289334adfb3a2"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}&lt;/script&gt;
&lt;p&gt;However, the problem of repeating top-level fields still
persists.&lt;/p&gt;
&lt;h2 id="grouping-and-aggregating"&gt;Grouping and Aggregating&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{reactable}&lt;/code&gt; has a &lt;strong&gt;groupBy&lt;/strong&gt; argument
which lets us combined rows with common data fields and the
&lt;strong&gt;aggregate&lt;/strong&gt; argument inside &lt;code&gt;colDef&lt;/code&gt; lets us
define what aggregation to be used for each column of the top-level
data.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;reactable(
  data       = combined_df,
  compact    = TRUE, # for minimum row height
  filterable = TRUE, # for individual column filters
  striped    = TRUE, # banded rows
  resizable  = TRUE, # for resizable column widths
  groupBy    = &amp;quot;course_id&amp;quot;,
  columns    = list(
    # show count of students in each course
    course_id   = colDef(name = &amp;quot;CID&amp;quot;,         width = 100,  align = &amp;quot;left&amp;quot;,    aggregate = &amp;quot;count&amp;quot;),  
    # show unique course name
    course_name = colDef(name = &amp;quot;Course Name&amp;quot;, width = 140,                     aggregate = &amp;quot;unique&amp;quot;), 
    # show unique start date
    start_date  = colDef(name = &amp;quot;Start Date&amp;quot;,  width = 120,  align = &amp;quot;center&amp;quot;,  aggregate = &amp;quot;unique&amp;quot;), 
    # show unique end date
    end_date    = colDef(name = &amp;quot;End Date&amp;quot;,    width = 120,  align = &amp;quot;center&amp;quot;,  aggregate = &amp;quot;unique&amp;quot;), 
    s_id        = colDef(name = &amp;quot;SID&amp;quot;,         width = 70,   align = &amp;quot;center&amp;quot;),
    s_name      = colDef(name = &amp;quot;Student Name&amp;quot;),
    gender      = colDef(name = &amp;quot;Gender&amp;quot;,      width = 80,   align = &amp;quot;center&amp;quot;),
    age         = colDef(name = &amp;quot;Age&amp;quot;,         width = 50)
  )
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id="htmlwidget-44db758151977091446d" class="reactable html-widget" style="width:auto;height:auto;"&gt;&lt;/div&gt;
&lt;script type="application/json" data-for="htmlwidget-44db758151977091446d"&gt;{"x":{"tag":{"name":"Reactable","attribs":{"data":{"course_id":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],"course_name":["Course A","Course A","Course A","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course C","Course C","Course C","Course C","Course D","Course D","Course D"],"start_date":["2021-01-01","2021-01-01","2021-01-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-03-01","2021-03-01","2021-03-01","2021-03-01","2021-04-01","2021-04-01","2021-04-01"],"end_date":["2021-01-31","2021-01-31","2021-01-31","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-03-31","2021-03-31","2021-03-31","2021-03-31","2021-04-30","2021-04-30","2021-04-30"],"s_id":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],"s_name":["Student D","Student E","Student N","Student F","Student G","Student H","Student I","Student J","Student M","Student O","Student Q","Student R","Student S","Student A","Student C","Student L","Student P","Student B","Student K","Student T"],"gender":["X","Y","Y","Y","Y","X","Z","Z","Y","Y","Z","X","X","X","X","X","Z","X","X","Z"],"age":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},"columns":[{"accessor":"course_id","name":"CID","type":"numeric","aggregate":"count","width":100,"align":"left"},{"accessor":"course_name","name":"Course Name","type":"character","aggregate":"unique","width":140},{"accessor":"start_date","name":"Start Date","type":"Date","aggregate":"unique","width":120,"align":"center"},{"accessor":"end_date","name":"End Date","type":"Date","aggregate":"unique","width":120,"align":"center"},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":80,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50}],"pivotBy":["course_id"],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"striped":true,"compact":true,"dataKey":"e9fc15f3a53a06ad3569f7b3f70a31cd"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}&lt;/script&gt;
&lt;p&gt;In this case, all the columns which are not &lt;code&gt;aggregate&lt;/code&gt;d
remain hidden. Clicking the little triangle in the &lt;code&gt;CID&lt;/code&gt;
column displays the hidden rows. Looks better, but again, the issue of
duplicated data remains.&lt;/p&gt;
&lt;p&gt;You can aggregate the second-level columns too, but this distorts the
table and frankly, looks ugly. Here I aggregate the &lt;code&gt;SID&lt;/code&gt;
column in addition to all the other top-level columns.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;reactable(
  data       = combined_df,
  compact    = TRUE, # for minimum row height
  filterable = TRUE, # for individual column filters
  striped    = TRUE, # banded rows
  resizable  = TRUE, # for resizable column widths
  groupBy    = &amp;quot;course_id&amp;quot;,
  columns    = list(
    course_id   = colDef(name = &amp;quot;CID&amp;quot;,         width = 100,  align = &amp;quot;left&amp;quot;,    aggregate = &amp;quot;count&amp;quot;),
    course_name = colDef(name = &amp;quot;Course Name&amp;quot;, width = 140,                     aggregate = &amp;quot;unique&amp;quot;),
    start_date  = colDef(name = &amp;quot;Start Date&amp;quot;,  width = 120,  align = &amp;quot;center&amp;quot;,  aggregate = &amp;quot;unique&amp;quot;),
    end_date    = colDef(name = &amp;quot;End Date&amp;quot;,    width = 120,  align = &amp;quot;center&amp;quot;,  aggregate = &amp;quot;unique&amp;quot;),
    # YIKES!! Aggregating Student ID to show unique ids in each course.
    s_id        = colDef(name = &amp;quot;SID&amp;quot;,         width = 70,   align = &amp;quot;center&amp;quot;,  aggregate = &amp;quot;unique&amp;quot;), 
    s_name      = colDef(name = &amp;quot;Student Name&amp;quot;),
    gender      = colDef(name = &amp;quot;Gender&amp;quot;,      width = 80,   align = &amp;quot;center&amp;quot;),
    age         = colDef(name = &amp;quot;Age&amp;quot;,         width = 50)
  )
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id="htmlwidget-67b62794e33863e62991" class="reactable html-widget" style="width:auto;height:auto;"&gt;&lt;/div&gt;
&lt;script type="application/json" data-for="htmlwidget-67b62794e33863e62991"&gt;{"x":{"tag":{"name":"Reactable","attribs":{"data":{"course_id":[1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,4,4,4],"course_name":["Course A","Course A","Course A","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course B","Course C","Course C","Course C","Course C","Course D","Course D","Course D"],"start_date":["2021-01-01","2021-01-01","2021-01-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-02-01","2021-03-01","2021-03-01","2021-03-01","2021-03-01","2021-04-01","2021-04-01","2021-04-01"],"end_date":["2021-01-31","2021-01-31","2021-01-31","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-02-28","2021-03-31","2021-03-31","2021-03-31","2021-03-31","2021-04-30","2021-04-30","2021-04-30"],"s_id":[4,5,14,6,7,8,9,10,13,15,17,18,19,1,3,12,16,2,11,20],"s_name":["Student D","Student E","Student N","Student F","Student G","Student H","Student I","Student J","Student M","Student O","Student Q","Student R","Student S","Student A","Student C","Student L","Student P","Student B","Student K","Student T"],"gender":["X","Y","Y","Y","Y","X","Z","Z","Y","Y","Z","X","X","X","X","X","Z","X","X","Z"],"age":[22,19,21,25,20,18,27,28,21,35,22,21,19,21,30,25,30,22,32,35]},"columns":[{"accessor":"course_id","name":"CID","type":"numeric","aggregate":"count","width":100,"align":"left"},{"accessor":"course_name","name":"Course Name","type":"character","aggregate":"unique","width":140},{"accessor":"start_date","name":"Start Date","type":"Date","aggregate":"unique","width":120,"align":"center"},{"accessor":"end_date","name":"End Date","type":"Date","aggregate":"unique","width":120,"align":"center"},{"accessor":"s_id","name":"SID","type":"numeric","aggregate":"unique","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":80,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50}],"pivotBy":["course_id"],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"striped":true,"compact":true,"dataKey":"51a6dfecd993aea3dbb11e027155fa81"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}&lt;/script&gt;
&lt;p&gt;Wouldn’t it be nice if we could display only the top-level columns by
default and on clicking the small triangle for a row, show all the
second-level columns corresponding to that row only, like a drill-down
table?&lt;/p&gt;
&lt;p&gt;To do this we need 2 separate tables. Earlier in this post, I said it
is advisable to split such denormalized data into normalized data
i.e. create the original top-level and second level tables from the
&lt;code&gt;combined_df&lt;/code&gt;. Let’s recreate the 2 tables.&lt;/p&gt;
&lt;p&gt;I want to demonstrate how we go from the combined data to the 2
tables. Hence I will not use the &lt;code&gt;course&lt;/code&gt; and
&lt;code&gt;student&lt;/code&gt; tables created earlier.&lt;/p&gt;
&lt;p&gt;Creating the &lt;code&gt;top_level&lt;/code&gt; table using just the columns in
&lt;code&gt;course&lt;/code&gt;. Let’s also create a new column
&lt;code&gt;n_students&lt;/code&gt; depicting count of students in each course.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;top_level &amp;lt;- combined_df %&amp;gt;% 
  # Only course info columns
  count(course_id, course_name, start_date, end_date, name = &amp;quot;n_students&amp;quot;) 

paged_table(top_level)&lt;/code&gt;&lt;/pre&gt;
&lt;div data-pagedtable="false"&gt;
&lt;script data-pagedtable-source type="application/json"&gt;
{"columns":[{"label":["course_id"],"name":[1],"type":["int"],"align":["right"]},{"label":["course_name"],"name":[2],"type":["chr"],"align":["left"]},{"label":["start_date"],"name":[3],"type":["date"],"align":["right"]},{"label":["end_date"],"name":[4],"type":["date"],"align":["right"]},{"label":["n_students"],"name":[5],"type":["int"],"align":["right"]}],"data":[{"1":"1","2":"Course A","3":"2021-01-01","4":"2021-01-31","5":"3"},{"1":"2","2":"Course B","3":"2021-02-01","4":"2021-02-28","5":"10"},{"1":"3","2":"Course C","3":"2021-03-01","4":"2021-03-31","5":"4"},{"1":"4","2":"Course D","3":"2021-04-01","4":"2021-04-30","5":"3"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  &lt;/script&gt;
&lt;/div&gt;
&lt;pre class="r"&gt;&lt;code&gt;second_level &amp;lt;- combined_df %&amp;gt;% 
  # Only Student info columns with unique identifier for Course
  select(course_id, s_id, s_name, gender, age) %&amp;gt;% 
  arrange(s_id)

paged_table(second_level)&lt;/code&gt;&lt;/pre&gt;
&lt;div data-pagedtable="false"&gt;
&lt;script data-pagedtable-source type="application/json"&gt;
{"columns":[{"label":["course_id"],"name":[1],"type":["int"],"align":["right"]},{"label":["s_id"],"name":[2],"type":["int"],"align":["right"]},{"label":["s_name"],"name":[3],"type":["chr"],"align":["left"]},{"label":["gender"],"name":[4],"type":["chr"],"align":["left"]},{"label":["age"],"name":[5],"type":["int"],"align":["right"]}],"data":[{"1":"3","2":"1","3":"Student A","4":"X","5":"21"},{"1":"4","2":"2","3":"Student B","4":"X","5":"22"},{"1":"3","2":"3","3":"Student C","4":"X","5":"30"},{"1":"1","2":"4","3":"Student D","4":"X","5":"22"},{"1":"1","2":"5","3":"Student E","4":"Y","5":"19"},{"1":"2","2":"6","3":"Student F","4":"Y","5":"25"},{"1":"2","2":"7","3":"Student G","4":"Y","5":"20"},{"1":"2","2":"8","3":"Student H","4":"X","5":"18"},{"1":"2","2":"9","3":"Student I","4":"Z","5":"27"},{"1":"2","2":"10","3":"Student J","4":"Z","5":"28"},{"1":"4","2":"11","3":"Student K","4":"X","5":"32"},{"1":"3","2":"12","3":"Student L","4":"X","5":"25"},{"1":"2","2":"13","3":"Student M","4":"Y","5":"21"},{"1":"1","2":"14","3":"Student N","4":"Y","5":"21"},{"1":"2","2":"15","3":"Student O","4":"Y","5":"35"},{"1":"3","2":"16","3":"Student P","4":"Z","5":"30"},{"1":"2","2":"17","3":"Student Q","4":"Z","5":"22"},{"1":"2","2":"18","3":"Student R","4":"X","5":"21"},{"1":"2","2":"19","3":"Student S","4":"X","5":"19"},{"1":"4","2":"20","3":"Student T","4":"Z","5":"35"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  &lt;/script&gt;
&lt;/div&gt;
&lt;h2 id="the-final-drill-down-table"&gt;The final Drill-down Table&lt;/h2&gt;
&lt;p&gt;Now that we have the 2 tables ready, let us now create the final
&lt;code&gt;{reactable}&lt;/code&gt;. The trick here is to use the
&lt;strong&gt;details&lt;/strong&gt; argument to which we pass another
&lt;code&gt;{reactable}&lt;/code&gt; of just the rows with students data
corresponding to given course.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;reactable(
  data       = top_level,
  compact    = TRUE, # for minimum row height
  filterable = TRUE, # for individual column filters
  striped    = TRUE, # banded rows
  resizable  = TRUE, # for resizable column widths
  columns    = list(
    course_id   = colDef(name = &amp;quot;CID&amp;quot;,             width = 50,  align = &amp;quot;center&amp;quot;),
    course_name = colDef(name = &amp;quot;Course Name&amp;quot;), 
    start_date  = colDef(name = &amp;quot;Start Date&amp;quot;,      width = 120, align = &amp;quot;center&amp;quot;),
    end_date    = colDef(name = &amp;quot;End Date&amp;quot;,        width = 120, align = &amp;quot;center&amp;quot;),
    n_students  = colDef(name = &amp;quot;No. of Students&amp;quot;, width = 130, align = &amp;quot;center&amp;quot;)
  ),
  details = function(index) { # index is the row number of current row.
    # sub-table of only those students for current row.
    sec_lvl = second_level[second_level$course_id == top_level$course_id[index], ] 
    reactable(data       = sec_lvl,
              compact    = TRUE, 
              filterable = TRUE,
              bordered   = TRUE, 
              resizable  = TRUE,
              columns    = list(
                course_id   = colDef(show = FALSE), # hide the course id column
                s_id        = colDef(name = &amp;quot;SID&amp;quot;,    width = 70, align = &amp;quot;center&amp;quot;),
                s_name      = colDef(name = &amp;quot;Student Name&amp;quot;),
                gender      = colDef(name = &amp;quot;Gender&amp;quot;, width = 90, align = &amp;quot;center&amp;quot;),
                age         = colDef(name = &amp;quot;Age&amp;quot;,    width = 50, align = &amp;quot;center&amp;quot;)
              )
              )
  }
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id="htmlwidget-5a0cb435521fcff53b1c" class="reactable html-widget" style="width:auto;height:auto;"&gt;&lt;/div&gt;
&lt;script type="application/json" data-for="htmlwidget-5a0cb435521fcff53b1c"&gt;{"x":{"tag":{"name":"Reactable","attribs":{"data":{"course_id":[1,2,3,4],"course_name":["Course A","Course B","Course C","Course D"],"start_date":["2021-01-01","2021-02-01","2021-03-01","2021-04-01"],"end_date":["2021-01-31","2021-02-28","2021-03-31","2021-04-30"],"n_students":[3,10,4,3]},"columns":[{"accessor":".details","name":"","type":"NULL","sortable":false,"resizable":false,"filterable":false,"searchable":false,"width":45,"align":"center","details":[{"name":"Reactable","attribs":{"data":{"course_id":[1,1,1],"s_id":[4,5,14],"s_name":["Student D","Student E","Student N"],"gender":["X","Y","Y"],"age":[22,19,21]},"columns":[{"accessor":"course_id","name":"course_id","type":"numeric","show":false},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":90,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50,"align":"center"}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"bordered":true,"compact":true,"dataKey":"12036566002706ab50f66831a92eae32","nested":true},"children":[]},{"name":"Reactable","attribs":{"data":{"course_id":[2,2,2,2,2,2,2,2,2,2],"s_id":[6,7,8,9,10,13,15,17,18,19],"s_name":["Student F","Student G","Student H","Student I","Student J","Student M","Student O","Student Q","Student R","Student S"],"gender":["Y","Y","X","Z","Z","Y","Y","Z","X","X"],"age":[25,20,18,27,28,21,35,22,21,19]},"columns":[{"accessor":"course_id","name":"course_id","type":"numeric","show":false},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":90,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50,"align":"center"}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"bordered":true,"compact":true,"dataKey":"6587f2ad3dcb0fcc5216bf4473c986a0","nested":true},"children":[]},{"name":"Reactable","attribs":{"data":{"course_id":[3,3,3,3],"s_id":[1,3,12,16],"s_name":["Student A","Student C","Student L","Student P"],"gender":["X","X","X","Z"],"age":[21,30,25,30]},"columns":[{"accessor":"course_id","name":"course_id","type":"numeric","show":false},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":90,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50,"align":"center"}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"bordered":true,"compact":true,"dataKey":"e3963514a17cdadfff8af46fde214632","nested":true},"children":[]},{"name":"Reactable","attribs":{"data":{"course_id":[4,4,4],"s_id":[2,11,20],"s_name":["Student B","Student K","Student T"],"gender":["X","X","Z"],"age":[22,32,35]},"columns":[{"accessor":"course_id","name":"course_id","type":"numeric","show":false},{"accessor":"s_id","name":"SID","type":"numeric","width":70,"align":"center"},{"accessor":"s_name","name":"Student Name","type":"character"},{"accessor":"gender","name":"Gender","type":"character","width":90,"align":"center"},{"accessor":"age","name":"Age","type":"numeric","width":50,"align":"center"}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"bordered":true,"compact":true,"dataKey":"5a3a2a276df6d52409d68b95331871bb","nested":true},"children":[]}]},{"accessor":"course_id","name":"CID","type":"numeric","width":50,"align":"center"},{"accessor":"course_name","name":"Course Name","type":"character"},{"accessor":"start_date","name":"Start Date","type":"Date","width":120,"align":"center"},{"accessor":"end_date","name":"End Date","type":"Date","width":120,"align":"center"},{"accessor":"n_students","name":"No. of Students","type":"numeric","width":130,"align":"center"}],"resizable":true,"filterable":true,"defaultPageSize":10,"paginationType":"numbers","showPageInfo":true,"minRows":1,"striped":true,"compact":true,"dataKey":"4234130aace77d06280744fa5876f205"},"children":[]},"class":"reactR_markup"},"evals":[],"jsHooks":[]}&lt;/script&gt;
&lt;p&gt;Since the sub-table is also a &lt;code&gt;{reactable}&lt;/code&gt;, you can go
another level down… and another, but please do consider the usability
aspect of this feature before taking that decision. I haven’t tried
going beyond 2 levels of data myself. Maybe a part 2 to this post??&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Drill-down tables let you pack a lot of data in a compact manner and
allow use by multiple audiences interested in varying degrees/levels of
information. &lt;code&gt;{reactable}&lt;/code&gt; can help create an interactive
data table from tabular data with sorting and pagination by default. The
data table is an HTML widget that can be used in R Markdown documents
and Shiny applications, or viewed from an R console. A lot of features
can be enabled/disabled using the basic arguments of the
&lt;code&gt;reactable()&lt;/code&gt; function and much more using custom
JavaScript.&lt;/p&gt;
&lt;h2 id="references-citations"&gt;References &amp;amp; Citations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Greg Lin (2020). reactable: Interactive Data Tables Based on ‘React
Table’. R package version 0.2.3. &lt;a
href="https://CRAN.R-project.org/package=reactable"
class="uri"&gt;https://CRAN.R-project.org/package=reactable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>fc859afe322459fd304fde238b6018d7</distill:md5>
      <category>Rstats</category>
      <category>reactable</category>
      <category>drill-down</category>
      <guid>https://vishalkatti.com/posts/2021-07-27-drilldown</guid>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2021-07-27-drilldown/images/drilldown.gif" medium="image" type="image/gif"/>
    </item>
    <item>
      <title>Programming with R {dplyr} - As I Understand It!!</title>
      <dc:creator>Vishal Katti</dc:creator>
      <link>https://vishalkatti.com/posts/2021-07-17-programmingwithdplyr</link>
      <description>


&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The purpose of this document is to act as a quick guide for myself
and others to understand how to use &lt;code&gt;dplyr&lt;/code&gt; effectively to
create dynamic functions. The general assumption is that the reader is
familiar with the &lt;code&gt;{dplyr}&lt;/code&gt; package and how to use it for
data wrangling.&lt;/p&gt;
&lt;p&gt;In this document, we will explore how to create functions using the
popular &lt;code&gt;dplyr&lt;/code&gt; verbs like &lt;code&gt;select&lt;/code&gt;,
&lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;mutate&lt;/code&gt;, &lt;code&gt;arrange&lt;/code&gt; and
finally &lt;code&gt;group_by&lt;/code&gt; with &lt;code&gt;summarise&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="inspiration"&gt;Inspiration&lt;/h3&gt;
&lt;p&gt;I regularly deal with event-related information with event date and
few other columns like event type, root cause etc. Most reports usually
involve calculating number of events that took place on a monthly,
quarterly or annual basis, sometimes split by event type, root cause and
other columns. After a few reports I realized that I am basically
writing the same code over and over again to calculate these KPIs.
Keeping the &lt;code&gt;DRY (Don't Repeat Yourself)&lt;/code&gt; principle in mind,
I managed to write a few functions to calculate these KPIs with a few
dynamic variables. Following is an attempt to articulate what I learnt
while creating those functions.&lt;/p&gt;
&lt;h3 id="data"&gt;Data&lt;/h3&gt;
&lt;p&gt;We shall use the Texas Housing Sales data, available as a tibble in
the popular &lt;code&gt;ggplot2&lt;/code&gt; package as reference data. It contains
monthly information about the housing market in Texas provided by the
TAMU real estate center, &lt;a href="https://www.recenter.tamu.edu/"
class="uri"&gt;https://www.recenter.tamu.edu/&lt;/a&gt;. It has 8602 observations
and 9 variables.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;txhousing &amp;lt;- ggplot2::txhousing
dplyr::glimpse(txhousing)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Rows: 8,602
Columns: 9
$ city      &amp;lt;chr&amp;gt; &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abile~
$ year      &amp;lt;int&amp;gt; 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 20~
$ month     &amp;lt;int&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4,~
$ sales     &amp;lt;dbl&amp;gt; 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100~
$ volume    &amp;lt;dbl&amp;gt; 5380000, 6505000, 9285000, 9730000, 10590000, 1391~
$ median    &amp;lt;dbl&amp;gt; 71400, 58700, 58100, 68600, 67300, 66900, 73500, 7~
$ listings  &amp;lt;dbl&amp;gt; 701, 746, 784, 785, 794, 780, 742, 765, 771, 764, ~
$ inventory &amp;lt;dbl&amp;gt; 6.3, 6.6, 6.8, 6.9, 6.8, 6.6, 6.2, 6.4, 6.5, 6.6, ~
$ date      &amp;lt;dbl&amp;gt; 2000.000, 2000.083, 2000.167, 2000.250, 2000.333, ~&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We shall refer the above data in all the following sections.&lt;/p&gt;
&lt;h1 id="select"&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;When using &lt;code&gt;dplyr&lt;/code&gt; functions, the two most popular ways to
pass column names is either as bare names i.e. column names without
enclosing them in quotes like &lt;code&gt;sales&lt;/code&gt; or &lt;code&gt;volume&lt;/code&gt;
OR pass them as a character string like “sales” or ‘volume’. You could
also pass a character vector like &lt;code&gt;c("sales", "volume")&lt;/code&gt;. In
this section we will explore the 3 ways to dynamically select the
columns we want.&lt;/p&gt;
&lt;h3 id="passing-raw-column-names"&gt;Passing raw column names&lt;/h3&gt;
&lt;p&gt;In this method, we pass the raw name of the column we want to select
and use the &lt;code&gt;embrace&lt;/code&gt; of curly-curly brackets to pass the raw
name. For multiple columns, we can pass the raw names as a single
vector.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;select_raw &amp;lt;- function(df, var) {
  dplyr::select(.data = df, {{var}}) %&amp;gt;%     # embrace of curly-curly {{}} brackets
    head()                                   # to limit the number of output rows in this example.
}
select_raw(txhousing, sales)                 # pass single raw name&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 1
  sales
  &amp;lt;dbl&amp;gt;
1    72
2    98
3   130
4    98
5   141
6   156&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;select_raw(txhousing, c(sales, volume))      # pass a vector of raw names for multiple columns&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 2
  sales   volume
  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
1    72  5380000
2    98  6505000
3   130  9285000
4    98  9730000
5   141 10590000
6   156 13910000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If passing multiple raw names as vector as in the
&lt;code&gt;select_raw()&lt;/code&gt; feels like an unnecessary complication, try
the next method.&lt;/p&gt;
&lt;h3 id="passing-multiple-raw-column-names-using-argument"&gt;Passing
multiple raw column names using … argument&lt;/h3&gt;
&lt;p&gt;In this method, we use the &lt;code&gt;.&lt;/code&gt; argument to pass the raw
names of the columns we want to select.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_select &amp;lt;- function(df, ...) {
  dplyr::select(.data = df, ...) %&amp;gt;% 
    head()
}

my_select(txhousing, sales, volume)          # pass multiple raw names directly&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 2
  sales   volume
  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
1    72  5380000
2    98  6505000
3   130  9285000
4    98  9730000
5   141 10590000
6   156 13910000&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="passing-a-character-vector-of-column-names"&gt;Passing a character
vector of column names&lt;/h3&gt;
&lt;p&gt;If we have the column names as a character vector, we use the
&lt;code&gt;all_of&lt;/code&gt; function to pass the character vector to the
internal &lt;code&gt;select&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_select_char &amp;lt;- function(df, cols) {
  dplyr::select(.data = df, dplyr::all_of(cols)) %&amp;gt;% 
    head()
}

my_cols &amp;lt;- c(&amp;quot;sales&amp;quot;,&amp;quot;volume&amp;quot;)
my_select_char(txhousing, my_cols)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 2
  sales   volume
  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
1    72  5380000
2    98  6505000
3   130  9285000
4    98  9730000
5   141 10590000
6   156 13910000&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="filter"&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;In the previous section, we passed column names either as bare names
or character strings. &lt;code&gt;filter()&lt;/code&gt; takes one or more
expressions/conditions that result in a logical vector, with same length
as number of rows in the data.frame/tibble and returns only those rows
for which the expression/condition returns &lt;code&gt;TRUE&lt;/code&gt;. Following
are 2 ways to pass these logical expressions/conditions. I’m using
expression and condition interchangeably here. In this context, a
condition is an expression that results in a boolean
&lt;code&gt;TRUE/FALSE&lt;/code&gt; result.&lt;/p&gt;
&lt;h3 id="passing-single-raw-criteria"&gt;Passing single raw criteria&lt;/h3&gt;
&lt;p&gt;In this method, we pass the condition &lt;code&gt;sales &amp;gt; 8000&lt;/code&gt; as
a raw/bare expression.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter_raw &amp;lt;- function(df, cond) {
  dplyr::filter(.data = df, {{cond}})        # embrace of curly-curly {{}} brackets
}

filter_raw(txhousing, sales &amp;gt; 8000)          # Pass a single raw criterion&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 10 x 9
   city     year month sales    volume median listings inventory  date
   &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.
 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.
 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.
 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.
 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.
 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.
 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.
 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.
 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.
10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do you think we can pass multiple bare conditions as a vector, like
we did for &lt;code&gt;select_raw()&lt;/code&gt; in the previous section? Let us try
passing multiple raw criteria as a vector.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;filter_raw(txhousing, c(sales &amp;gt; 8000, year &amp;gt; 2010))&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in `dplyr::filter()`:
! Problem while computing `..1 = c(sales &gt; 8000, year &gt;
  2010)`.
x Input `..1` must be of size 8602 or 1, not size 17204.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Passing multiple raw criteria as a vector doesn’t work like it works
for &lt;code&gt;select_raw()&lt;/code&gt; function. Let us understand why. Consider
the following code:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;A &amp;lt;- c(TRUE, TRUE)                           # boolean vector of length = 2
B &amp;lt;- c(FALSE, FALSE)                         # boolean vector of length = 2
X &amp;lt;- c(A, B)
X&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1]  TRUE  TRUE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that length of X is 4. Similarly, &lt;code&gt;sales &amp;gt; 8000&lt;/code&gt;
evaluates to a TRUE/FALSE boolean vector of length 8602 (equal to number
of rows in &lt;code&gt;txhousing&lt;/code&gt;) and so does
&lt;code&gt;year &amp;gt; 2010&lt;/code&gt;. So the vector
&lt;code&gt;c(sales &amp;gt; 8000, year &amp;gt; 2010)&lt;/code&gt; becomes a TRUE/FALSE
boolean vector of length 17204, which results in an error.&lt;/p&gt;
&lt;h3 id="passing-multiple-raw-criteria-using-argument"&gt;Passing multiple
raw criteria using … argument&lt;/h3&gt;
&lt;p&gt;To pass multiple raw criteria, we can use the &lt;code&gt;...&lt;/code&gt;
argument.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_filter &amp;lt;- function(df, ...) { 
  dplyr::filter(.data = df, ...)                # pass the dots argument
  }

my_filter(txhousing, sales &amp;gt; 8000, year &amp;gt; 2010) # pass multiple raw criteria&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 8 x 9
  city     year month sales     volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.
2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.
3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.
4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.
5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.
6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.
7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.
8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="passing-single-criteria-as-a-character-string"&gt;Passing single
criteria as a character string&lt;/h3&gt;
&lt;p&gt;By default, &lt;code&gt;dplyr::filter()&lt;/code&gt; does not accept conditions
as character strings. Following is an example which results in error&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dplyr::filter(txhousing, &amp;quot;sales &amp;gt; 8000&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in `dplyr::filter()`:
! Problem while computing `..1 = "sales &gt; 8000"`.
x Input `..1` must be a logical vector, not a character.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to convert the character condition into a raw expression.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_filter_string &amp;lt;- function(df, cond) {
  dplyr::filter(.data = df, eval(parse(text = cond)))   # convert text to raw criterion
}

my_filter_string(txhousing, &amp;quot;sales &amp;gt; 8000&amp;quot;)             # pass single text string as criteria&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 10 x 9
   city     year month sales    volume median listings inventory  date
   &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1 Houston  2006     5  8040    1.60e9 151200    35398       5.5 2006.
 2 Houston  2006     6  8628    1.80e9 155200    36281       5.6 2006.
 3 Houston  2013     5  8439    2.12e9 186100    20526       3.3 2013.
 4 Houston  2013     7  8468    2.17e9 187800    21497       3.3 2014.
 5 Houston  2013     8  8155    2.08e9 186700    21366       3.3 2014.
 6 Houston  2014     6  8391    2.34e9 211200    19725       2.9 2014.
 7 Houston  2014     7  8391    2.28e9 199700    20214       3   2014.
 8 Houston  2014     8  8167    2.20e9 202400    20007       2.9 2015.
 9 Houston  2015     6  8449    2.49e9 222400    22311       3.2 2015.
10 Houston  2015     7  8945    2.57e9 217600    23875       3.4 2016.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The special sauce here is the &lt;code&gt;eval(parse(text = ...))&lt;/code&gt;
combo that converts the long text criteria into a single raw criteria
and passes it to the internal &lt;code&gt;filter()&lt;/code&gt; function.&lt;/p&gt;
&lt;h3 id="passing-multiple-criteria-as-character-vector"&gt;Passing multiple
criteria as character vector&lt;/h3&gt;
&lt;p&gt;What if want to pass multiple criteria as a string vector? In such a
situation, we must combine all the string conditions into a single long
string condition using &lt;code&gt;paste0(..., collapse = " &amp;amp; ")&lt;/code&gt;.
The &lt;code&gt;paste0("(", cond, ")", collapse = " &amp;amp; ")&lt;/code&gt; combines
all the criteria into a single long criteria, but still a text
string.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_filter_strings &amp;lt;- function(df, cond) { 
  filter_text &amp;lt;- paste0(&amp;quot;(&amp;quot;, cond, &amp;quot;)&amp;quot;, collapse = &amp;quot; &amp;amp; &amp;quot;)   # combine all criteria
  message(&amp;quot;Filter Condition: &amp;quot;, filter_text)                # (OPTIONAL) show the combined filter string
  dplyr::filter(.data = df, eval(parse(text = filter_text)))# convert text to raw criterion
  }

my_filter_criteria &amp;lt;- c(&amp;quot;sales &amp;gt; 8000&amp;quot;, &amp;quot;year &amp;gt; 2010&amp;quot;)
my_filter_strings(txhousing, my_filter_criteria)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 8 x 9
  city     year month sales     volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.
2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.
3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.
4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.
5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.
6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.
7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.
8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;my_filter_criteria_with_OR &amp;lt;- c(&amp;quot;sales &amp;gt; 8000 | sales &amp;lt; 50&amp;quot;, &amp;quot;year &amp;gt; 2010&amp;quot;)

# NOTE: OR criteria must be a single string separated by pipe &amp;#39;|&amp;#39; as in example below.
my_filter_strings(txhousing, my_filter_criteria_with_OR)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 315 x 9
   city        year month sales volume median listings inventory  date
   &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1 Brownsvil~  2011     1    48 4.97e6  83300      784      12.6 2011 
 2 Brownsvil~  2011     2    47 5.56e6 101400      776      12.7 2011.
 3 Brownsvil~  2011     7    47 4.81e6  91200      749      13.1 2012.
 4 Brownsvil~  2011    12    39 4.20e6  86800      726      12.4 2012.
 5 Brownsvil~  2012     1    43 3.89e6  85000      791      13.6 2012 
 6 Brownsvil~  2012     3    27 2.98e6  93800      734      13.3 2012.
 7 Brownsvil~  2012    11    41 5.12e6  99000      807      14   2013.
 8 Brownsvil~  2013    11    38 4.82e6 108000      859      13.4 2014.
 9 Brownsvil~  2015     1    41 5.40e6  97000      733      10.7 2015 
10 Galveston   2011     1    43 8.88e6 170000     1015      13.7 2011 
# ... with 305 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="mutate"&gt;&lt;code&gt;mutate()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;mutate()&lt;/code&gt; allows you to add new columns or modify
existing columns. In the example below, we will create a new column
&lt;code&gt;volume_in_millions&lt;/code&gt; from the existing column
&lt;code&gt;volume&lt;/code&gt;. The names of both the columns can be passed to the
function either as raw names or character strings.&lt;/p&gt;
&lt;h3 id="passing-the-column-name-as-raw-name"&gt;Passing the column name as
raw name&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;mutate_raw &amp;lt;- function(df, new_col_raw, old_col_raw, num = 1) { 
  dplyr::mutate(.data = df, {{new_col_raw}} := {{old_col_raw}}/num) %&amp;gt;% 
    head()
}

txhousing %&amp;gt;% 
  select(city, year, month, volume) %&amp;gt;% 
  mutate_raw(vol_in_millions, volume, 1E6) # pass raw column names w/o quotes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 5
  city     year month   volume vol_in_millions
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;
1 Abilene  2000     1  5380000            5.38
2 Abilene  2000     2  6505000            6.50
3 Abilene  2000     3  9285000            9.28
4 Abilene  2000     4  9730000            9.73
5 Abilene  2000     5 10590000           10.6 
6 Abilene  2000     6 13910000           13.9 &lt;/code&gt;&lt;/pre&gt;
&lt;h3
id="passing-the-new-variable-name-as-character-string-direct"&gt;Passing
the new variable name as character string (direct)&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;mutate_text &amp;lt;- function(df, new_col_str, old_col_str, num = 1) { 
  dplyr::mutate(.data = df, {{new_col_str}} := df[[old_col_str]]/num) %&amp;gt;% 
    head()
}

txhousing %&amp;gt;% 
  select(city, year, month, volume) %&amp;gt;%
  mutate_text(&amp;quot;vol_in_millions&amp;quot;, &amp;quot;volume&amp;quot;, 1E6) # pass column names as strings&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 5
  city     year month   volume vol_in_millions
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;
1 Abilene  2000     1  5380000            5.38
2 Abilene  2000     2  6505000            6.50
3 Abilene  2000     3  9285000            9.28
4 Abilene  2000     4  9730000            9.73
5 Abilene  2000     5 10590000           10.6 
6 Abilene  2000     6 13910000           13.9 &lt;/code&gt;&lt;/pre&gt;
&lt;h3
id="passing-the-new-variable-name-as-character-string-indirect"&gt;Passing
the new variable name as character string (indirect)&lt;/h3&gt;
&lt;p&gt;Instead of passing the name of the variable as a character string as
an argument, we can pass a variable containing the name of the variable.
In the below example, the name of the new variable is stored in
&lt;code&gt;new_var&lt;/code&gt;. Using the new &lt;code&gt;{glue}&lt;/code&gt; syntax, enabled
by the walrus operator &lt;code&gt;:=&lt;/code&gt;, we substitute the
&lt;code&gt;new_var&lt;/code&gt; variable with its value.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;mutate_var &amp;lt;- function(df, new_col_var, old_col_var, num = 1) {
  dplyr::mutate(.data = df, &amp;quot;{new_col_var}&amp;quot; := df[[old_col_var]]/num) %&amp;gt;% 
    head()
}

new_var &amp;lt;- &amp;quot;vol_in_millions&amp;quot;
old_var &amp;lt;- &amp;quot;volume&amp;quot;

txhousing %&amp;gt;% 
  select(city, year, month, volume) %&amp;gt;%
  mutate_var(new_var, old_var, 1E6)  # pass column names as variables&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 5
  city     year month   volume vol_in_millions
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;
1 Abilene  2000     1  5380000            5.38
2 Abilene  2000     2  6505000            6.50
3 Abilene  2000     3  9285000            9.28
4 Abilene  2000     4  9730000            9.73
5 Abilene  2000     5 10590000           10.6 
6 Abilene  2000     6 13910000           13.9 &lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="arrange"&gt;&lt;code&gt;arrange()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;arrange()&lt;/code&gt; sorts the rows of a data frame by the values
of selected columns. By default, it sorts in Ascending order. To force a
column to sort in Descending order, we must use the &lt;code&gt;desc()&lt;/code&gt;
function.&lt;/p&gt;
&lt;h3 id="passing-single-raw-name"&gt;Passing single raw name&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_raw &amp;lt;- function(df, var) {
  dplyr::arrange(.data = df, {{var}}) %&amp;gt;%    # embrace of curly-curly {{}} brackets
    head()
}

arrange_raw(txhousing, sales)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city         year month sales volume median listings inventory  date
  &amp;lt;chr&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.
2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.
3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 
4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 
5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.
6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_raw(txhousing, desc(sales))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city     year month sales     volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.
2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.
3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.
4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.
5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.
6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arrange_raw()&lt;/code&gt; fails when we pass multiple raw names as a
vector.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_raw(txhousing, c(sales, volume))&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="color: red;"&gt;&lt;code&gt;Error in `dplyr::arrange()`:
! Problem with the implicit `transmute()` step.
x Problem while computing `..1 = c(sales, volume)`.
x `..1` must be size 8602 or 1, not 17204.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="passing-multiple-raw-names-using-...-argument"&gt;Passing multiple
raw names using &lt;code&gt;...&lt;/code&gt; argument&lt;/h3&gt;
&lt;p&gt;To pass multiple raw names, we must use the &lt;code&gt;...&lt;/code&gt;
argument.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_raw_multiple &amp;lt;- function(df, ...) {
  dplyr::arrange(.data = df, ...) %&amp;gt;% 
    head()
}

arrange_raw_multiple(txhousing, city, sales)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city     year month sales  volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Abilene  2003     1    68 5385000  70000      668       5.4  2003
2 Abilene  2011     1    68 8834493 123300      809       6.1  2011
3 Abilene  2009     1    70 8414801  92900      861       6.3  2009
4 Abilene  2000     1    72 5380000  71400      701       6.3  2000
5 Abilene  2010     1    73 9130783 112200      868       6.4  2010
6 Abilene  2001     1    75 5730000  64500      779       6.8  2001&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_raw_multiple(txhousing, city, desc(sales))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city     year month sales   volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Abilene  2015     7   268 45845730 148700      986       5   2016.
2 Abilene  2015     6   260 41396230 141500      965       5   2015.
3 Abilene  2007     7   239 29315000 114300      940       5.2 2008.
4 Abilene  2013     8   236 30777727 120000      976       5.4 2014.
5 Abilene  2014     7   231 35861350 145800     1033       5.8 2014.
6 Abilene  2005     6   230 24050000  92500      664       4.1 2005.&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="pass-single-column-name-as-string"&gt;Pass single column name as
string&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_str &amp;lt;- function(df, var, .desc = FALSE) {
  if (.desc) {
    dplyr::arrange(.data = df, desc(df[[var]])) %&amp;gt;% head()
  } else {
    dplyr::arrange(.data = df, df[[var]]) %&amp;gt;% head()
  }
}

arrange_str(txhousing, &amp;quot;sales&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city         year month sales volume median listings inventory  date
  &amp;lt;chr&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 San Marcos   2011    10     6 1.16e6 180000      163       8.3 2012.
2 Harlingen    2000     7     9 1.11e6  87500      719      30.8 2000.
3 South Padr~  2011     1     9 2.09e6 225000     1258      55.7 2011 
4 San Marcos   2011     1    10 1.48e6 140000      165       7.5 2011 
5 San Marcos   2011    12    10 1.56e6 140000      148       8   2012.
6 San Marcos   2014    11    10 1.51e6 146700       96       4   2015.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_str(txhousing, &amp;quot;sales&amp;quot;, .desc = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city     year month sales     volume median listings inventory  date
  &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.
2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.
3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.
4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.
5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.
6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="pass-multiple-column-name-as-string"&gt;Pass multiple column name
as string&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_str_multiple &amp;lt;- function(df, var, desc = FALSE) {
  if (desc) {
    dplyr::arrange(.data = df, desc(df[var])) %&amp;gt;% head()
  } else {
    dplyr::arrange(.data = df, df[var]) %&amp;gt;% head()
  }
}

# This function arranges the dataframe either all ascending
# or all descending. Definitely need a better example.

arrange_str_multiple(txhousing, c(&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;sales&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city         year month sales volume median listings inventory  date
  &amp;lt;chr&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Paris        2000     1    19 1.44e6  71700      286       7.5  2000
2 San Marcos   2000     1    22 2.38e6 106700      190       6.3  2000
3 Lufkin       2000     1    28 2.28e6  68000       NA      NA    2000
4 Harlingen    2000     1    31 3.91e6  87500      644      24.9  2000
5 Galveston    2000     1    37 4.56e6  95000      636       9.1  2000
6 Port Arthur  2000     1    40 3.09e6  68300      314       5.6  2000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;arrange_str_multiple(txhousing, c(&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;sales&amp;quot;), desc = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 6 x 9
  city         year month sales volume median listings inventory  date
  &amp;lt;chr&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 Houston      2015     7  8945 2.57e9 217600    23875       3.4 2016.
2 Dallas       2015     7  7038 2.02e9 233000    12292       2.4 2016.
3 Austin       2015     7  3466 1.15e9 264600     7913       3   2016.
4 San Antonio  2015     7  2962 7.05e8 198100     9462       4.1 2016.
5 Collin Cou~  2015     7  1861 6.14e8 292600     2809       2.1 2016.
6 Fort Bend    2015     7  1372 4.32e8 280400     3328       3.1 2016.&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="group_by"&gt;&lt;code&gt;group_by()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;In &lt;code&gt;group_by()&lt;/code&gt;, we &lt;em&gt;select&lt;/em&gt; which columns to,
well, group by! (Damn these well-named functions!). So one can use the
same techniques as &lt;code&gt;select()&lt;/code&gt; to choose the columns.&lt;/p&gt;
&lt;p&gt;In the following examples, we will create only one summarised value
&lt;code&gt;total_sales&lt;/code&gt; for simplicity.&lt;/p&gt;
&lt;h3 id="passing-single-raw-name-1"&gt;Passing single raw name&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw &amp;lt;- function(df, grp) {
  df %&amp;gt;% 
    group_by({{grp}}) %&amp;gt;% 
    summarise(total_sales = sum(sales, na.rm = TRUE),
              .groups = &amp;#39;drop&amp;#39;)  %&amp;gt;% 
    head(n=5)
}

group_raw(txhousing, year)        # Sum of sales per year&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
   year total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000      222483
2  2001      231453
3  2002      234600
4  2003      253909
5  2004      283999&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw(txhousing, month)       # Sum of sales per month&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
  month total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1     1      245924
2     2      296410
3     3      386909
4     4      397332
5     5      448968&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="passing-multiple-raw-names-using-the-...-operator"&gt;Passing
multiple raw names using the &lt;code&gt;...&lt;/code&gt; operator&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw_multiple &amp;lt;- function(df, ...) {
  df %&amp;gt;% 
    group_by(...) %&amp;gt;% 
    summarise(total_sales = sum(sales, na.rm = TRUE),
              .groups = &amp;#39;drop&amp;#39;)  %&amp;gt;% 
    head(n = 5)
}

group_raw_multiple(txhousing, year)              # Sum of sales per year&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
   year total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000      222483
2  2001      231453
3  2002      234600
4  2003      253909
5  2004      283999&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw_multiple(txhousing, year, month)       # Sum of sales per month&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 3
   year month total_sales
  &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000     1       11411
2  2000     2       15674
3  2000     3       20202
4  2000     4       18658
5  2000     5       22388&lt;/code&gt;&lt;/pre&gt;
&lt;h3
id="passing-single-or-multiple-column-names-as-character-string"&gt;Passing
single or multiple column names as character string&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_str &amp;lt;- function(df, grp) {
  df %&amp;gt;% 
    group_by(df[grp]) %&amp;gt;% 
    summarise(total_sales = sum(sales, na.rm = TRUE),
              .groups = &amp;#39;drop&amp;#39;)  %&amp;gt;% 
    head(n=5)
}

group_str(txhousing, &amp;quot;year&amp;quot;)                   # Sum of sales per year&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
   year total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000      222483
2  2001      231453
3  2002      234600
4  2003      253909
5  2004      283999&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_str(txhousing, c(&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;))       # Sum of sales per month&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 3
   year month total_sales
  &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000     1       11411
2  2000     2       15674
3  2000     3       20202
4  2000     4       18658
5  2000     5       22388&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# The same column names can be passed as variables containing the character names
yr &amp;lt;- &amp;quot;year&amp;quot;
group_str(txhousing, yr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
   year total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000      222483
2  2001      231453
3  2002      234600
4  2003      253909
5  2004      283999&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;yrmon &amp;lt;- c(&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;)
group_str(txhousing, yrmon)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 3
   year month total_sales
  &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000     1       11411
2  2000     2       15674
3  2000     3       20202
4  2000     4       18658
5  2000     5       22388&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want the summarise column to have a custom name like
&lt;code&gt;total_&amp;lt;sumvar&amp;gt;&lt;/code&gt;, then you can wrap the value in quotes
as below. This method uses the &lt;code&gt;glue&lt;/code&gt; syntax enabled by the
&lt;code&gt;:=&lt;/code&gt; walrus operator. The walrus operator takes either a raw
name or a character string on its LHS.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw2 &amp;lt;- function(df, grp, sumvar) {
  df %&amp;gt;% 
    group_by({{grp}}) %&amp;gt;% 
    summarise(&amp;quot;total_{{sumvar}}&amp;quot; := sum({{sumvar}}, na.rm = TRUE),
              .groups = &amp;#39;drop&amp;#39;)  %&amp;gt;% 
    head(n=5)
}

group_raw2(txhousing, year, sales)            # Sum of sales per year&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
   year total_sales
  &amp;lt;int&amp;gt;       &amp;lt;dbl&amp;gt;
1  2000      222483
2  2001      231453
3  2002      234600
4  2003      253909
5  2004      283999&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;group_raw2(txhousing, month, listings)        # Sum of listings per month&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 5 x 2
  month total_listings
  &amp;lt;int&amp;gt;          &amp;lt;dbl&amp;gt;
1     1        1854661
2     2        1888104
3     3        1949187
4     4        1991278
5     5        2038932&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After writing so many examples, I see a pattern.
&lt;code&gt;group_by()&lt;/code&gt; works with techniques similar to
&lt;code&gt;select()&lt;/code&gt; while &lt;code&gt;summarise()&lt;/code&gt; works with
techniques similar to &lt;code&gt;mutate()&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="slightly-better-examples"&gt;(Slightly Better) Examples&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;txhousing&lt;/code&gt; is a city-wise monthly sales and volume
dataset. It has a &lt;code&gt;year&lt;/code&gt; and &lt;code&gt;month&lt;/code&gt; column. Let
us create a &lt;code&gt;date&lt;/code&gt; column and keep only those columns
relevant for our custom &lt;code&gt;tx_summary()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;small_df &amp;lt;- txhousing %&amp;gt;% 
  mutate(date = lubridate::as_date(glue::glue(&amp;quot;{year}-{month}-01&amp;quot;))) %&amp;gt;% 
  select(city, date, sales, volume)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="mutate-example"&gt;&lt;code&gt;mutate()&lt;/code&gt; example&lt;/h3&gt;
&lt;p&gt;Now let us create the &lt;code&gt;create_ymq()&lt;/code&gt; function. This
function would take 2 arguments, a data frame &lt;code&gt;df&lt;/code&gt; and a raw
name of a date column.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;create_ymq &amp;lt;- function(df, date_col) {
  stopifnot(inherits(df, &amp;quot;data.frame&amp;quot;))
  stopifnot(class(df %&amp;gt;% dplyr::pull({{date_col}})) == &amp;#39;Date&amp;#39;)
  dplyr::mutate(df,
                Year = lubridate::year({{date_col}}),
                nHalf = lubridate::semester({{date_col}}),
                yHalf = lubridate::semester({{date_col}}, with_year = TRUE),
                dHalf = paste0(lubridate::semester({{date_col}}), &amp;quot;H&amp;quot;, format({{date_col}},&amp;quot;%y&amp;quot;)),
                nQtr = lubridate::quarter({{date_col}}),
                yQtr = lubridate::quarter({{date_col}}, with_year = TRUE),
                dQtr = paste0(lubridate::quarter({{date_col}}),&amp;quot;Q&amp;quot;, format({{date_col}},&amp;quot;%y&amp;quot;)),
                Month = lubridate::month({{date_col}}),
                yMonth = as.numeric(format({{date_col}}, &amp;quot;%Y.%m&amp;quot;)),
                dMonth = format({{date_col}}, &amp;quot;%b %Y&amp;quot;)
                )
}

create_ymq(df = small_df, date_col = date) %&amp;gt;% glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Rows: 8,602
Columns: 14
$ city   &amp;lt;chr&amp;gt; &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;, &amp;quot;Abilene&amp;quot;~
$ date   &amp;lt;date&amp;gt; 2000-01-01, 2000-02-01, 2000-03-01, 2000-04-01, 2000~
$ sales  &amp;lt;dbl&amp;gt; 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100, 9~
$ volume &amp;lt;dbl&amp;gt; 5380000, 6505000, 9285000, 9730000, 10590000, 1391000~
$ Year   &amp;lt;dbl&amp;gt; 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000,~
$ nHalf  &amp;lt;int&amp;gt; 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,~
$ yHalf  &amp;lt;dbl&amp;gt; 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.~
$ dHalf  &amp;lt;chr&amp;gt; &amp;quot;1H00&amp;quot;, &amp;quot;1H00&amp;quot;, &amp;quot;1H00&amp;quot;, &amp;quot;1H00&amp;quot;, &amp;quot;1H00&amp;quot;, &amp;quot;1H00&amp;quot;, &amp;quot;2H00~
$ nQtr   &amp;lt;int&amp;gt; 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2,~
$ yQtr   &amp;lt;dbl&amp;gt; 2000.1, 2000.1, 2000.1, 2000.2, 2000.2, 2000.2, 2000.~
$ dQtr   &amp;lt;chr&amp;gt; &amp;quot;1Q00&amp;quot;, &amp;quot;1Q00&amp;quot;, &amp;quot;1Q00&amp;quot;, &amp;quot;2Q00&amp;quot;, &amp;quot;2Q00&amp;quot;, &amp;quot;2Q00&amp;quot;, &amp;quot;3Q00~
$ Month  &amp;lt;dbl&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5,~
$ yMonth &amp;lt;dbl&amp;gt; 2000.01, 2000.02, 2000.03, 2000.04, 2000.05, 2000.06,~
$ dMonth &amp;lt;chr&amp;gt; &amp;quot;Jan 2000&amp;quot;, &amp;quot;Feb 2000&amp;quot;, &amp;quot;Mar 2000&amp;quot;, &amp;quot;Apr 2000&amp;quot;, &amp;quot;May ~&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="group_by-example"&gt;&lt;code&gt;group_by()&lt;/code&gt; example&lt;/h3&gt;
&lt;p&gt;Now that we have a function that creates various date-related
columns, let us create a function that let’s you create summary tables
like annual sales per city, quarterly volumes per city etc.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tx_summary &amp;lt;- function(df, grp_col, sum_col) {
  df %&amp;gt;% 
    group_by(city, {{grp_col}}) %&amp;gt;% 
    summarise(&amp;quot;total_{{sum_col}}&amp;quot; := sum({{sum_col}}, na.rm = TRUE), .groups = &amp;#39;drop&amp;#39;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using these 2 functions, we can now create multiple summary
tables&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;small_df_with_date_cols &amp;lt;- small_df %&amp;gt;% create_ymq(date_col = date)

# Annual Sales per city
small_df_with_date_cols %&amp;gt;% tx_summary(grp_col = Year, sum_col = sales)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 736 x 3
   city     Year total_sales
   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
 1 Abilene  2000        1375
 2 Abilene  2001        1431
 3 Abilene  2002        1516
 4 Abilene  2003        1632
 5 Abilene  2004        1830
 6 Abilene  2005        1977
 7 Abilene  2006        1997
 8 Abilene  2007        2003
 9 Abilene  2008        1651
10 Abilene  2009        1634
# ... with 726 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Half Yearly volumes per city
small_df_with_date_cols %&amp;gt;% tx_summary(grp_col = yHalf, sum_col = volume)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 1,472 x 3
   city    yHalf total_volume
   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
 1 Abilene 2000.     55400000
 2 Abilene 2000.     53175000
 3 Abilene 2001.     55795000
 4 Abilene 2001.     58570000
 5 Abilene 2002.     55305000
 6 Abilene 2002.     63370000
 7 Abilene 2003.     58175000
 8 Abilene 2003.     77500000
 9 Abilene 2004.     74205000
10 Abilene 2004.     85465000
# ... with 1,462 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Quarterly Sales per city
small_df_with_date_cols %&amp;gt;% tx_summary(grp_col = yQtr, sum_col = sales)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 2,898 x 3
   city     yQtr total_sales
   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
 1 Abilene 2000.         300
 2 Abilene 2000.         395
 3 Abilene 2000.         387
 4 Abilene 2000.         293
 5 Abilene 2001.         305
 6 Abilene 2001.         394
 7 Abilene 2001.         401
 8 Abilene 2001.         331
 9 Abilene 2002.         295
10 Abilene 2002.         425
# ... with 2,888 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Monthly Volumes per city
small_df_with_date_cols %&amp;gt;% tx_summary(grp_col = yMonth, sum_col = volume)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 8,602 x 3
   city    yMonth total_volume
   &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
 1 Abilene  2000.      5380000
 2 Abilene  2000.      6505000
 3 Abilene  2000.      9285000
 4 Abilene  2000.      9730000
 5 Abilene  2000.     10590000
 6 Abilene  2000.     13910000
 7 Abilene  2000.     12635000
 8 Abilene  2000.     10710000
 9 Abilene  2000.      7615000
10 Abilene  2000.      7040000
# ... with 8,592 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="more-ideas"&gt;More ideas&lt;/h3&gt;
&lt;p&gt;You could further extend this by creating a custom filtering function
that gives you, say, the rows with the highest or lowest
&lt;code&gt;total_sales&lt;/code&gt; or &lt;code&gt;total_volume&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The ability to create such dynamic functions, enabled by the
wonderful {dplyr} package, allows us to level-up in terms of programming
with R and helps make our code neat and tidy.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://vishalkatti.com/posts/2021-07-17-programmingwithdplyrthor.gif" alt="" /&gt;
&lt;p class="caption"&gt;How I feel while creating custom functions with
{dplyr}! I can almost hear the music! Source: gifer.com&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Hadley Wickham, Romain François, Lionel Henry and Kirill Müller
(2022). dplyr: A Grammar of Data Manipulation. R package version 1.0.9.
&lt;a href="https://CRAN.R-project.org/package=dplyr"
class="uri"&gt;https://CRAN.R-project.org/package=dplyr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dplyr.tidyverse.org/articles/programming.html"
class="uri"&gt;https://dplyr.tidyverse.org/articles/programming.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;H. Wickham. ggplot2: Elegant Graphics for Data Analysis.
Springer-Verlag New York, 2016. &lt;a href="https://ggplot2.tidyverse.org"
class="uri"&gt;https://ggplot2.tidyverse.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jim Hester and Jennifer Bryan (2022). glue: Interpreted String
Literals. R package version 1.6.2. &lt;a
href="https://CRAN.R-project.org/package=glue"
class="uri"&gt;https://CRAN.R-project.org/package=glue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>a2c77bea8fd261d15b71bd9fda6218e8</distill:md5>
      <category>Rstats</category>
      <category>dplyr</category>
      <category>functions</category>
      <guid>https://vishalkatti.com/posts/2021-07-17-programmingwithdplyr</guid>
      <pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate>
      <media:content url="https://vishalkatti.com/posts/2021-07-17-programmingwithdplyr/thor.gif" medium="image" type="image/gif"/>
    </item>
  </channel>
</rss>
