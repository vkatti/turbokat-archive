---
title: "Writing Robust R Functions"
description: |
  Best Practises for validating function arguments.
author:
  - name: Vishal Katti
    url: {}
date: 2022-01-18
preview: https://64.media.tumblr.com/f6dc1e64c3d63e1f308e46445cafb6ab/tumblr_mo7km0eiRW1qedb29o1_500.gif
categories:
  - Rstats
  - functions
output:
  distill::distill_article:
    self_contained: false
    toc: true
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Introduction

Functions in R ( or any other programming language in general) allow us
to encapsulate some lines of code that we want to run again and again.
Functions are the natural outcome of the **DRY** (Don't Repeat
Yourself!) principle. Functions group together a couple of lines of
consistent logic making our code modular and consequently, easy to
manage. However, when we write functions, we need to ensure that they
behave exactly as we want them to and are able to handle whatever we
throw at them. By whatever, I mean any and all kinds of inputs. The idea
of creating unbreakable code is idealistic. I say this since creating
robust functions requires additional code to handle the unwanted inputs
and most developers write functions during some one-time analysis. Hence
we need to be pragmatic about how much time and effort we spend trying
to make our functions robust. Maybe, we need our functions to be just
robust enough! All I am saying is, if you are creating functions that
will be used by you and only you i.e. if you have absolute control over
what inputs would be provided to your functions, then you can forego
certain checks and the functions need not be unbreakable. But, if you
intend to write functions that will be used by a larger audience, you
need to ensure that such functions are able to handle all kinds of
innocent and malicious intents.

## What do we mean by Robust Functions?

You must be familiar with the *Garbage-In-Garbage-Out* philosophy of
Software engineering. We can think of it in terms of functions, that,
given garbage or bad input, you get garbage or bad output. For a
function to be robust, it must behave in a consistent manner for known
and correct inputs, however, more importantly, it mustn't give us
garbage for bad inputs. Rather, it must provide useful output which can
be further used to inform the end-user about possible problems in the
inputs to drive proper usage. The useful output/s in case of bad inputs
would ideally be a combination of clean early exit with some clean-up
code and easy-to-understand error messages. So we shall try to implement
*Garbage-In-Useful-Info-Out* by looking at some ways we can build
well-behaved and reliable functions.

Input values passed to a function are more popularly known as arguments
or parameters. A robust function must validate the function arguments
before proceeding to implement the function logic. If this is not done,
then the bad arguments will cause some errors in the logic and display
error messages that the end-user may not be familiar with. Worst-case
scenario is when the function doesn't encounter any errors and just
gives bad results!! Surely, we do not want this unpredictable behavior.

![Enough Talk, Let's Fight! - Kungfu Panda
\@imgflip.com](https://i.imgflip.com/28bxz3.jpg){style="float:left;"
width="300"}

## Missing Arguments

The most basic check we should perform before running the function logic is to confirm if all the required arguments are available.

Consider the following function. Function `make_date` takes 3 numeric inputs `yyyy`, `mm` and `dd` and returns a 'Date` object.

```{r}
make_date <-  function(yyyy, mm, dd) {
  out_date <- as.Date(paste(yyyy, mm, dd, sep = "-"), format = "%Y-%m-%d")
  return(out_date)
}

make_date(yyyy = 2022, mm = 1, dd = 31)
```

We will use `make_date` to demonstrate a couple of scenarios where this function can fail.


## Scenario 1: Missing Arguments

2 ways to handle missing inputs: 1. early break 2: sensible defaults

## Scenario 2: Invalid Data Type of Arguments
check if char input is coersible to number?
check class using inherits

## Scenario 3: Incorrect Data Size
Check length, unintended behavior of vectorization
make_date(2021, 1:12, 1) works
make_date(2021, 1:12, 31) returns NA for invalid dates.

## Scenario 4: Invalid Values of Arguments

implement try-catch







![As robust as Superman! Source:
Tumblr](https://64.media.tumblr.com/f6dc1e64c3d63e1f308e46445cafb6ab/tumblr_mo7km0eiRW1qedb29o1_500.gif)

## Citations & References

-   [Techniques for writing robust R programs -
    LexJansen](https://www.lexjansen.com/phuse/2014/ts/TS03.pdf)
-   [R Programming for Data
    Science](https://bookdown.org/rdpeng/rprogdatascience/functions.html)
